<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CRAFT WORK</title>

<script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script defer src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://unpkg.com/@studio-freight/lenis/dist/lenis.min.js"></script>

<style>
  /* ===== Fonts ===== */
  @font-face {
    font-family: 'Suit';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_suit@1.0/SUIT-Light.woff2') format('woff2');
    font-weight: 300; font-display: swap;
  }
  @font-face {
    font-family: 'BookkMyungjo';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkMyungjo-Lt.woff2') format('woff2');
    font-weight: 400; font-display: swap;
  }
  @font-face {
    font-family: 'BookkGothic';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkGothic-Bd.woff2') format('woff2');
    font-weight: 700; font-display: swap;
  }

  :root{
    --ink:#0a0a0a;
    --muted:#6b7280;
    --gutter: clamp(16px, 4vw, 48px);
    --z-header: 100;
    --z-overlay: 90;
    --hero-bg:#ffffff;
    --panels: 3;
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  html{ scroll-behavior:auto; }
  body{
    margin:0; color:var(--ink); background:var(--hero-bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
    line-height:1.45; overflow-x:hidden;
    background-color: #f0f0f0;
  }

  /* ===== Header / Menu ===== */
  .site-header{
    position: fixed; inset: 0 0 auto 0; height: 64px; z-index: var(--z-header);
    display: grid; grid-template-columns: 1fr 1fr; align-items: center;
    padding: 8px var(--gutter); pointer-events: none;
  }

  /* í—¤ë”(í™ˆ/ë©”ë‰´ ì•„ì´ì½˜)ë¥¼ í™”ë©´ ìƒë‹¨ì—ì„œ â†“ë¡œ ì¡°ê¸ˆ ë‚´ë¦¬ê¸° */
.site-header{
  top: 18px !important;   /* â† ë‚´ë ¤ê°€ëŠ” ì–‘: 12~28px ì‚¬ì´ë¡œ ì·¨í–¥ ì¡°ì ˆ */
  left: 0;
  right: 0;
}

/* ì•„ì´ì½˜ì„ ì¡°ê¸ˆ ë” ì—¬ìœ  ìˆê²Œ ë³´ì´ê³  ì‹¶ìœ¼ë©´ ë²„íŠ¼ ìì²´ë„ ì‚´ì§ ë‚´ë¦¬ê¸°(ì˜µì…˜) */
.site-header .icon-btn{
  transform: translateY(2px); /* 0~6px ì‚¬ì´ë¡œ ì¡°ì ˆ */
}
  .header-left{ justify-self: start; }
  .header-right{ justify-self: end; }
  .icon-btn{
    pointer-events: auto; appearance: none; border: 0; background: transparent; cursor: pointer;
    width: 44px; height: 44px; display: inline-grid; place-items: center;
    border-radius: 999px; transition: background .2s ease;
  }
  .icon-btn:hover{ background: rgba(0,0,0,.06); }
  .icon-btn:focus-visible{ outline: 2px solid #111; outline-offset: 2px; }
  .home-svg{ width: 22px; height: 22px; fill:none; stroke:#111; stroke-width:2; }
  .menu-btn .burger{ display:grid; gap:4px; }
  .menu-btn .burger span{ width:20px; height:2px; background:#111; display:block; transition: transform .25s, opacity .25s; }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(2){ opacity:0; }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(1){ transform: translateY(6px) rotate(45deg); }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(3){ transform: translateY(-6px) rotate(-45deg); }
  .hm-overlay{ position: fixed; inset:0; background: rgba(0,0,0,.35); display:none; z-index: var(--z-overlay); }
  .hm-overlay.open{ display:grid; place-items: stretch; }
  .hm-panel{
    margin-left:auto; width:min(500px, 90vw); height:100%;
    background:#060010; color:#fff; position:relative;
    transform: translateX(100%); transition: transform .45s cubic-bezier(.19,1,.22,1);
    box-shadow: -12px 0 24px rgba(0,0,0,.25);
  }
  .hm-overlay.open .hm-panel{ transform: translateX(0); }
  #react-menu-root{ height:100%; }
  .fm-menu-wrap{ width:100%; height:100%; overflow:hidden; background:#060010; }
  .fm-menu{ display:flex; flex-direction:column; height:100%; margin:0; padding:0;    grid-template-rows: repeat(4, 1fr);   justify-content: space-evenly; }
  .fm-menu__item{  position: relative;
  overflow: hidden;
  text-align: center;
  box-shadow: 0 -1px var(--fm-divider);
  display: grid;
  place-items: center; /* ìˆ˜ì§/ìˆ˜í‰ ì¤‘ì•™ */
  height: 100%;
  min-height: unset;   /* ë†’ì´ ê°•ì œê°’ í•´ì œ(í° í™”ë©´ì—ì„œ ìƒë‹¨ ì¹˜ìš°ì¹¨ ë°©ì§€) */}
.menu-items { height: 100%; }
  .fm-menu__item-link{
  display: grid;
  place-items: center;
  width: 100%;
  height: 100%;
  cursor: pointer;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  font-weight: 600;
  color: var(--fm-fg);
  font-size: clamp(18px, 4vh, 42px);
  outline: none;
font-family:'BookkGothic';
      font-weight:600; color:#fff;
  }
  .fm-menu__item-link:focus-visible{ outline:2px solid #fff; outline-offset: -4px; }
  .fm-marquee{ position:absolute; inset:0; overflow:hidden; pointer-events:none; background:#fff;
    transform: translate3d(0,101%,0); transition: transform .6s cubic-bezier(.19,1,.22,1); }
  .fm-marquee__inner-wrap{ height:100%; width:200%; display:flex; transform:translateX(0); }
  .fm-marquee__inner{ display:flex; align-items:center; height:100%; width:200%; will-change:transform; animation: fm-marquee 15s linear infinite; }
  .fm-marquee span{ color:#060010; white-space:nowrap; text-transform:uppercase; font-weight:400;
    font-size:clamp(16px,4vh,36px); line-height:1.2; padding:1vh 1vw 0; }
  .fm-marquee__img{ width:200px; height:7vh; min-height:42px; margin:2em 2vw; padding:1em 0; border-radius:50px; background-size:cover; background-position:50% 50%; }
  @keyframes fm-marquee{ from{transform:translateX(0)} to{transform:translateX(-50%)} }

  /* ===== Hero + ImageTrail ===== */
  .hero{ position:relative; min-height:100svh; padding: clamp(12px, 2vw, 24px) var(--gutter) max(10vh, 64px);
    display:grid; align-items:center; justify-content:center; background:var(--hero-bg); overflow:hidden; }
  .hero-inner{ width:100%; text-align:center; position:relative; z-index:1; }
  .hero-title-wrap{ position:relative; display:inline-block; }
  .hero-title{ margin:0 auto; font-size: max(48vw, 90vh); line-height:.86; letter-spacing:-.02em; font-weight:900; color:#000;
    white-space:nowrap; display:inline-block; transform-origin:center; }
  .hero-desc{
    font-family: 'BookkMyungjo', serif; max-width:140ch; margin: clamp(16px, 2vh, 32px) auto 0;
    font-size: clamp(13px, 1.5vw, 16px); line-height: 1.9; color: #2b2b2b; letter-spacing: -0.01em;
  }
  .image-trail-layer{ position:absolute; inset:0; z-index:60; pointer-events:auto; }
  .content{ width:100%; height:100%; position:relative; z-index:60; background: transparent; overflow: visible; }
  .content__img { position: absolute; top: 0; left: 0; opacity: 0; overflow: hidden; will-change: transform, filter; border-radius: 15px; width: 190px; aspect-ratio: 1.1; }
  .content__img-inner { display: block; width: 100%; height: 100%; object-fit: contain; background: none !important; }

  /* ===== Interlude ===== */
  .interlude{ height: 350vh; padding: 0 var(--gutter); display:block; background:var(--hero-bg); border-block: 1px solid #e5e5dc; }
  .interlude--circle .interlude__wrap{ position: sticky; top: 0; min-height: 100svh; max-width: 1100px; margin: 0 auto;
    display:grid; place-content:center; justify-items:center; text-align:center; gap: 24px; padding: clamp(48px,  8vw, 120px) 0; }
  .interlude--circle .interlude__desc{ font-family: 'BookkMyungjo', serif; color:#2b2b2b; letter-spacing:-.01em; line-height:1.9;
    font-size: clamp(14px, 1.6vw, 18px); max-width: 72ch; margin: 0 auto; white-space: normal; }
  .interlude__desc .w{ display:inline-block; opacity:0; transform: translateY(16px); will-change: transform, opacity; margin-right:.28em; vertical-align:baseline; white-space:nowrap; }
  .circle-hero{ width: min(52vw, 440px); 
    aspect-ratio: 16 / 10; 
    border-radius: 9999px; 
    overflow:hidden; 
    display:grid; 
    place-items:center; 
    background:#f3f3eb; 
    box-shadow: 0 12px 34px rgba(0,0,0,.08); 
    will-change: transform; 

    /* [ì¶”ê°€] ì˜ì‚¬ ìš”ì†Œ(::before, ::after)ì˜ ê¸°ì¤€ì ì´ ë˜ë„ë¡ ì„¤ì • */
    position: relative; 
    /* [ì¶”ê°€] í´ë¦­ ê°€ëŠ¥í•œ ìš”ì†Œì„ì„ ì•”ì‹œ */
    cursor: pointer; }

    /* [ì¶”ê°€] ì´ë¯¸ì§€ ìœ„ ì–´ë‘ìš´ íšŒìƒ‰ í•„í„° */
.circle-hero::before {
  content: "";
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.45); /* ì‚´ì§ ì–´ë‘ìš´ íšŒìƒ‰ */
  border-radius: 9999px; /* ë¶€ëª¨ì™€ ë™ì¼í•œ ë‘¥ê·¼ ëª¨ì„œë¦¬ */
  z-index: 1; /* ì´ë¯¸ì§€ ìœ„, í…ìŠ¤íŠ¸ ì•„ë˜ */
  transition: opacity 0.3s ease-out;
  opacity: 0;
  pointer-events: none; /* [ì¶”ê°€] ì´ í•„í„°ê°€ ë§ˆìš°ìŠ¤ í´ë¦­ì„ ê°€ë¡œì±„ì§€ ì•Šë„ë¡ ì„¤ì • */
}

  /* [ì¶”ê°€] "ì´ë¯¸ì§€ë¥¼ í´ë¦­í•´ë³´ì„¸ìš”" í…ìŠ¤íŠ¸ */
  .circle-hero::after {
    content: "ì´ë¯¸ì§€ë¥¼ í´ë¦­í•´ë³´ì„¸ìš”";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-family: 'Suit', sans-serif;
    font-size: clamp(14px, 1.2vw, 20px); /* í°íŠ¸ í¬ê¸° */
    font-weight: 300;
    z-index: 2; /* ì˜¤ë²„ë ˆì´ ìœ„ */
    transition: opacity 0.3s ease-out;
    opacity: 0;
    pointer-events: none; /* í…ìŠ¤íŠ¸ê°€ ë§í¬ í´ë¦­ì„ ë°©í•´í•˜ì§€ ì•Šë„ë¡ í•¨ */
    white-space: nowrap; /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
  }

  /* [ì¶”ê°€] í˜¸ë²„ ì‹œ í•„í„°ì™€ í…ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸° */
  .circle-hero:hover::before,
  .circle-hero:hover::after {
    opacity: 0;
  }
  .circle-hero img{ width:110%; height:110%; object-fit:cover; transform: translate3d(0,0,0) scale(1); transform-origin:50% 50%; will-change: transform; }

  /* ===== Horizontal Scroll Section Layout ===== */
  .hscroll-new {
    height: calc(var(--panels) * 100vh + 100vh);
    background-color: #f0f0f0;
    position: relative;
    z-index: 1;
  }
  .hscroll-sticky {
    position: sticky;
    top: 0;
    height: 100vh;
    overflow: hidden;
  }
  .hscroll-track {
    display: flex;
    height: 100vh;
    gap: 0;
  }
  .panel {
    border-left: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    justify-content: center;
    flex-basis: 0;
    flex-shrink: 0;
    flex-grow: 1;
    background: #fff;
    box-shadow: 0 12px 30px rgba(0,0,0,.04);
    transition: flex-grow 1.1s cubic-bezier(.22,.61,.36,1);
    height: 100vh;
    overflow: hidden;
  }
  .panel.is-active{
    box-shadow: 0 16px 48px rgba(0,0,0,.08);
  }

  .panel-content {
    display: flex;
    flex-direction: row;
    align-items: center;
    width: 100%;
    height: 100%;
    padding: 0 5vw;
    gap: 5vw;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity .6s ease, transform .6s ease;
    pointer-events: none;
  }
  .panel.is-open .panel-content {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
    transition-delay: .1s;
  }

  .panel-image-wrapper {
    flex: 1 1 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  .panel-image {
    width: 100%;
    height: auto;
    max-height: 60vh;
    object-fit: contain;
  }

  .panel-text-wrapper {
    flex: 1 1 45%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: #111;
  }

  .panel-header {
    display: flex;
    align-items: baseline;
    gap: 16px;
    border-bottom: 1px solid #e5e7eb;
    padding-bottom: 22px; /* Adjusted */
    margin-bottom: 44px;  /* Adjusted */
    width: 100%;
  }

  .panel-number {     font-family: 'BookkGothic';font-size: clamp(16px, 1.1vw, 22px); font-weight: 700; color: #94a3b8; transition: transform .45s ease; }
  .panel-title  {     font-family: 'BookkGothic';font-size: clamp(28px, 2.5vw, 42px); font-weight: 700; margin: 0; color:#111; transition: transform .45s ease; }
  .panel.is-open .panel-number,
  .panel.is-open .panel-title { transform: translateY(16px); } /* Adjusted */

  .panel-footer {
     font-size: 14px;
  }
  .panel-meta {
    text-transform: uppercase;
    color: #64748b;
    letter-spacing: .08em;
    font-size: clamp(12px, 0.9vw, 16px);
  }
  .panel-desc {
    margin-top: 16px;
    color: #374151;
    line-height: 1.8;
    font-family: 'Suit';
    font-size: clamp(15px, 1.0vw, 18px);
  }

  .panel:not(.is-active) {
    cursor: pointer;
  }
  .panel:not(.is-active) .panel-content {
    display: none;
  }
  .panel:not(.is-active) .panel-header-collapsed {
    display: flex;
    writing-mode: vertical-rl;

    align-items: center;
    justify-content: center;
    height: 100%;
    gap: 20px;
    opacity: 0.5;
    transition: opacity 0.3s ease;
  }
  .panel:not(.is-active):hover .panel-header-collapsed {
    opacity: 1;
  }
  .panel:not(.is-active) .panel-number,
  .panel:not(.is-active) .panel-title {
     font-size: clamp(20px, 1.6vw, 34px);
  }
 /* Adjusted */
  .panel:not(.is-active) .panel-header-collapsed .panel-number,
  .panel:not(.is-active) .panel-header-collapsed .panel-title {
    transform: translateY(6px);
  }

  .panel { flex: 1 0 0; }
  .panel.is-active { flex: 12 0 0; }

  @media (max-width: 1024px) {
    .panel { padding: 0 32px; justify-content: flex-start; }
    .panel-content { flex-direction: column; padding: 20px 0; gap: 20px; opacity: 0; transform: translateY(16px); pointer-events:none; }
    .panel.is-open .panel-content { opacity: 1; transform: none; pointer-events:auto; transition: opacity .45s ease .05s, transform .45s ease .05s; }
    .panel-image-wrapper, .panel-text-wrapper { flex-basis: auto; }
    .panel:not(.is-active) .panel-header-collapsed { display: none; }
    .panel:not(.is-active) .panel-header { display: flex; }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 20px 0 18px;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 0;
    }
     .panel-footer {
        padding-top: 8px;
        opacity: 0;
        transform: translateY(10px);
        max-height: 0;
        overflow: hidden;
        pointer-events: none;
        transition: opacity .35s ease, transform .35s ease, max-height .5s ease;
      }
      .panel.is-active .panel-footer {
        opacity: 1;
        transform: translateY(0);
        max-height: 50vh;
        overflow: auto;
        pointer-events: auto;
        transition-delay: .6s;
      }
  }


  /* ===== Gallery after ===== */
  .un-section{
    display:flex;
    justify-content:center;
    align-items:center;
    width:100%;
    padding:60px 0;
    background:var(--hero-bg);
    position: relative;
    z-index: 2;
  }
  .image-list{display:flex;flex-direction:column;align-items:center;gap:60px}
  .image-item{display:flex;flex-direction:column;align-items:center;width:460px}
  .image-item img{width:100%;height:auto;margin:0;transform:scale(1);transition:transform .35s cubic-bezier(.22,.61,.36,1)}
  .image-item img:hover{ transform: scale(1.05); }

  /* ===== 4K ëŒ€ì‘ íŒ¨ì¹˜ ===== */
  :root{
    --gutter: clamp(16px, 3.5vw, 64px);
  }
  .content__img{
    width: clamp(140px, 10vw, 280px);
    border-radius: clamp(10px, 1vw, 18px);
  }
  .interlude--circle .interlude__desc{
    font-size: clamp(16px, 1.2vw, 22px);
  }
  .interlude--circle .interlude__wrap{
    max-width: min(1400px, 86vw);
  }
  .circle-hero{
    width: clamp(360px, 40vw, 720px);
  }

  .image-list{
    gap: clamp(40px, 6vh, 100px);
  }
  .image-item{
    width: clamp(280px, 24vw, 720px);
  }
  .image-item img{
    border-radius: clamp(8px, 0.8vw, 16px);
  }
  @media (min-width: 1600px){
    .site-header{ height: 72px; padding-inline: max(24px, 4vw); top: 20px; }
  }

  /* === ìŠ¤í¬ë¡¤ ë©ˆì¶¤ ë°©ì§€: hscroll ì•„ë˜ ì—¬ìœ  ë†’ì´ ì¶”ê°€ === */
.hscroll-new::after {
  content: "";
  display: block;
  height: 200vh; /* ì¶”ê°€ ìŠ¤í¬ë¡¤ ì—¬ìœ  ê³µê°„ */
}

/* 27ì¸ì¹˜ ëª¨ë‹ˆí„° ê¸°ì¤€ (1600px ì´ìƒ) */
@media (min-width: 1600px) {
  .interlude--circle .interlude__wrap {
    padding-top: 13vh;   /* í™”ë©´ ìƒë‹¨ìœ¼ë¡œë¶€í„° ì—¬ë°± */
    padding-bottom: 10vh; /* ì•„ë˜ìª½ ê· í˜• ë§ì¶”ê¸° */
    transform: translateY(3vh); /* ì „ì²´ ì½˜í…ì¸ ë¥¼ ì•„ë˜ë¡œ ì‚´ì§ ì´ë™ */
  }
}

@media (min-width: 1600px) {
  .interlude--circle .interlude__wrap {
    padding-top: 13vh;   /* í™”ë©´ ìƒë‹¨ìœ¼ë¡œë¶€í„° ì—¬ë°± */
    padding-bottom: 10vh; /* ì•„ë˜ìª½ ê· í˜• ë§ì¶”ê¸° */
    transform: translateY(3vh); /* ì „ì²´ ì½˜í…ì¸ ë¥¼ ì•„ë˜ë¡œ ì‚´ì§ ì´ë™ */
    gap: 6vw; /* ê¸°ì¡´ë³´ë‹¤ ê°„ê²© ë„“í˜ */
  }

  /* í˜¹ì‹œ gapì´ ì ìš©ë˜ì§€ ì•ŠëŠ” flex êµ¬ì¡°ë¼ë©´ marginìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥ */
  .interlude--circle .interlude__text {
    margin-right: 6vw; /* í…ìŠ¤íŠ¸ì™€ ì´ë¯¸ì§€ ì‚¬ì´ ì—¬ìœ  */
  }

  /* [ì¶”ê°€] 27ì¸ì¹˜ ëª¨ë‹ˆí„°ì—ì„œ circle-hero í¬ê¸° í™•ëŒ€ */
  .circle-hero {
    /* ê¸°ì¡´ 40vw, 720px -> 45vw, 820pxë¡œ í™•ëŒ€ */
    width: clamp(360px, 45vw, 820px);
  }

}


</style>
</head>
<body>

<header class="site-header" role="banner">
  <div class="header-left">
    <a class="icon-btn" href="index.html" aria-label="Home">
      <svg class="home-svg" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 10.5 12 3l9 7.5M5 9.5V21h14V9.5" />
      </svg>
    </a>
  </div>

  <div class="header-right">
    <button id="menuBtn" class="icon-btn menu-btn" type="button" aria-expanded="false" aria-controls="menuPanel" aria-label="Open menu">
      <span class="burger"><span></span><span></span><span></span></span>
    </button>
  </div>
</header>
<div id="menuOverlay" class="hm-overlay" aria-hidden="true">
  <aside id="menuPanel" class="hm-panel" role="dialog" aria-modal="true" aria-label="Navigation menu">
    <div class="menu-items"><div id="react-menu-root"></div></div>
  </aside>
</div>

<section class="hero" id="hero">
  <div class="hero-inner">
    <div class="image-trail-layer" id="image-trail-root">
      <div id="trail-srcs" data-variant="1" style="display:none">
        <img src="img/gong/back/5.png" alt=""> <img src="img/gong/back/a1.png" alt=""> <img src="img/gong/b.png" alt="">
        <img src="img/gong/back/ccc.png" alt=""> <img src="img/gong/ch.png" alt=""> <img src="img/gong/back/crafts.png" alt="">
        <img src="img/gong/back/cup.png" alt=""> <img src="img/gong/back/p.png" alt="">
      </div>
    </div>
    <div class="hero-title-wrap">
      <h1 class="hero-title" id="heroTitle">KOREAN&nbsp;&nbsp;&nbsp;CRAFTS*</h1>
    </div>
    <p class="hero-desc">
      ìš°ë¦¬ë‚˜ë¼ì˜ ì „í†µê³µì˜ˆí’ˆì€ ì‹¤ìš©ì„±ê³¼ ì˜ˆìˆ ì„±ì„ ì¡°í™”ë¡­ê²Œ ê°–ì¶˜ ìƒí™œ ì†ì˜ ì˜ˆìˆ ì…ë‹ˆë‹¤.<br />
      ìì—°ì—ì„œ ì–»ì€ ì¬ë£Œë¡œ ì˜¤ëœ ì‹œê°„ ë‹¤ë“¬ê³  ì •ì„±ê» ë§Œë“  ê³µì˜ˆí’ˆì—ëŠ” ì¡°ìƒë“¤ì˜ ì§€í˜œì™€ ë¯¸ì  ê°ê°ì´ ê³ ìŠ¤ë€íˆ ë‹´ê²¨ ìˆìŠµë‹ˆë‹¤.
    </p>
  </div>
</section>

<section class="interlude interlude--circle" id="overview">
  <div class="interlude__wrap">
    <p id="interlude-desc" class="interlude__desc">
      ë„ìê¸°ëŠ” í™ìœ¼ë¡œ ë¹šì€ ê·¸ë¦‡ì„ êµ¬ì›Œë‚´ëŠ” ë°©ë²•ì— ë”°ë¼ í† ê¸°(åœŸå™¨), ë„ê¸°(é™¶å™¨), ìê¸°(ç“·å™¨)ë¡œ ë‚˜ëˆ„ì–´ì§€ëŠ”ë°,
      ë°±í†  ë“±ì´ í˜¼í•©ë˜ì–´ ë†’ì€ ì˜¨ë„ì—ì„œ êµ¬ì›Œë‚¸ ê·¸ë¦‡ì„ ì‚¬ê¸°(ìê¸°)ë¼ê³  í•©ë‹ˆë‹¤.
    </p>
    <figure class="circle-hero" aria-hidden="true">
      <a href="explore.html">
      <img id="circleImg" src="img/gong/do.png" alt="ë„ìê¸° ì œì‘ ì¥ë©´">
      </a>
    </figure>
  </div>
</section>

<section class="hscroll-new" id="crafts-hscroll">
  <div class="hscroll-sticky">
    <div class="hscroll-track" id="crafts-track">
      <article class="panel" id="hs-baekja">
        <div class="panel-header-collapsed">
           <span class="panel-number">01</span>
           <h3 class="panel-title">ë°±ì</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/b.png" alt="ë°±ì">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">01</span>
              <h3 class="panel-title">ë°±ì Â· White Porcelain</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">CERAMICS / JOSEON DYNASTY</p>
              <p class="panel-desc">
                ë°±ìëŠ” ìˆœìˆ˜ì™€ ì ˆì œë¯¸ë¥¼ ìƒì§•í•˜ë©°, ì¡°ì„ ì‹œëŒ€ ì„ ë¹„ë“¤ì˜ ì •ì‹ ì„ ë‹´ì€ ëŒ€í‘œ ë„ìê¸°ì…ë‹ˆë‹¤. ìˆœë°±ì˜ ìœ ì•½ê³¼ ë‹¨ì •í•œ ë¹„ë¡€ê°, êµ°ë”ë”ê¸° ì—†ëŠ” ì„ ì´ íŠ¹ì§•ìœ¼ë¡œ, ì¼ìƒìš©ê¸°ë¶€í„° ì˜ë¡€ìš©, ë‹¬í•­ì•„ë¦¬ ê°™ì€ ëŒ€í˜• ê¸°ë¬¼ê¹Œì§€ í­ë„“ê²Œ ì œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ê´‘ì£¼ ë¶„ì› ê´€ìš” ë“±ì—ì„œ ì •ì œëœ ë°±í† ì™€ ë†’ì€ ì˜¨ë„ì˜ ê°€ë§ˆ ì†Œì„±ì´ ë”í•´ì ¸ ë§‘ê³  ë‹¨ë‹¨í•œ ì§ˆê°ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </div>
      </article>
      <article class="panel" id="hs-cheongja">
        <div class="panel-header-collapsed">
           <span class="panel-number">02</span>
           <h3 class="panel-title">ì²­ì</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/ch.png" alt="ì²­ì">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">02</span>
              <h3 class="panel-title">ì²­ì Â· Celadon</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">CERAMICS / GORYEO DYNASTY</p>
              <p class="panel-desc">
                ì²­ìëŠ” ë¹„ì·¨ë¹›(ë¹„ìƒ‰) ìœ ì•½ì´ í¬ì¸íŠ¸ë¡œ, ê¹Šê³  ì€ì€í•œ ìƒ‰ì¡°ì™€ ë§¤ë„ëŸ¬ìš´ í‘œë©´ê°ì´ ë‹ë³´ì…ë‹ˆë‹¤. ì—°ê½ƒÂ·í•™Â·ìš´ë¬¸ ë“±ì˜ ë¬¸ì–‘ì„ ìƒê°Â·ìŒê° ë“± ë‹¤ì–‘í•œ ê¸°ë²•ìœ¼ë¡œ í‘œí˜„í–ˆìœ¼ë©°, ì •êµí•˜ë©´ì„œë„ ì ˆì œëœ ì¥ì‹ë¯¸ë¡œ ê³ ë ¤ ê·€ì¡± ë¬¸í™”ì˜ ë¯¸ê°ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ê°€ë§ˆì˜ ìœ„ì¹˜ì™€ ì†Œì„± ì¡°ê±´ì— ë”°ë¼ ìƒ‰ì¡°ê°€ ë¯¸ë¬˜í•˜ê²Œ ë‹¬ë¼ì§€ëŠ” ê²ƒë„ ë§¤ë ¥ì…ë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </div>
      </article>
      <article class="panel" id="hs-najeon">
         <div class="panel-header-collapsed">
           <span class="panel-number">03</span>
           <h3 class="panel-title">ë‚˜ì „ì¹ ê¸°</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/n.png" alt="ë‚˜ì „ì¹ ê¸°">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">03</span>
              <h3 class="panel-title">ë‚˜ì „ì¹ ê¸°</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">LACQUERWARE / TRADITIONAL</p>
              <p class="panel-desc">
                ë‚˜ì „ì¹ ê¸°ëŠ” ì–‡ê²Œ ê°„ ìê°œ ì¡°ê°ì„ ì •êµí•˜ê²Œ ë°°ì—´í•˜ê³ , ì—¬ëŸ¬ ì°¨ë¡€ì˜ ì˜»ì¹ ê³¼ ì—°ë§ˆë¥¼ ê±°ì³ ê¹Šì€ ê´‘íƒì„ ì™„ì„±í•˜ëŠ” ê³µì˜ˆì…ë‹ˆë‹¤. ì „ë³µÂ·ì§„ì£¼ì¡°ê°œì˜ ì˜¤ë¬˜í•œ ìƒ‰ì´ ì–´ë‘ìš´ ì¹  ë°”íƒ•ê³¼ ëŒ€ë¹„ë˜ì–´ í™”ë ¤í•˜ë©´ì„œë„ ê³ ê¸‰ìŠ¤ëŸ¬ìš´ ë¶„ìœ„ê¸°ë¥¼ ë§Œë“­ë‹ˆë‹¤. ê¸´ ê±´ì¡°Â·ì—°ë§ˆ ê³µì •ì„ í†µí•´ ë‚´êµ¬ì„±ê³¼ í‘œë©´ ê°•ë„ê°€ ë†’ì•„ ì‹¤ìš©ì„±ê³¼ ì¥ì‹ì„±ì´ í•¨ê»˜ ì¶©ì¡±ë©ë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </div>
      </article>
    </div>
  </div>
</section>

<div class="un-section" id="un">
  <div class="image-list">
    <div class="image-item"><a href="explore.html?filter=baekja"><img src="img/gong/stack1.png" class="fade-in" alt="ë°±ì"></a></div>
    <div class="image-item"><a href="explore.html?filter=cheongja"><img src="img/gong/stack3.png" class="fade-in" alt="ì²­ì"></a></div>
    <div class="image-item"><a href="explore.html?filter=najeon"><img src="img/gong/stack2.png" class="fade-in" alt="ë‚˜ì „ì¹ ê¸°"></a></div>
  </div>
</div>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useRef } = React;

  /* ===== Utils ===== */
  function lerp(a,b,n){ return (1-n)*a + n*b; }
  function getLocalPointerPos(e, rect){
    let clientX = 0, clientY = 0;
    if (e.touches && e.touches.length > 0){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    return { x: clientX - rect.left, y: clientY - rect.top };
  }
  function getMouseDistance(p1, p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y; return Math.hypot(dx, dy); }

  /* ===== ImageTrail ===== */
  class ImageItem {
    DOM = { el:null, inner:null }; defaultStyle = { scale:1, x:0, y:0, opacity:0 }; rect=null;
    constructor(DOM_el){ this.DOM.el = DOM_el; this.DOM.inner = this.DOM.el.querySelector('.content__img-inner'); this.getRect(); this.initEvents(); }
    initEvents(){ this.resize = () => { if (typeof gsap !== 'undefined') gsap.set(this.DOM.el, this.defaultStyle); this.getRect(); }; window.addEventListener('resize', this.resize); } // Added gsap check
    getRect(){ this.rect = this.DOM.el.getBoundingClientRect(); }
  }
  class ImageTrailVariant1{
    constructor(container){
      this.container = container; this.DOM = { el: container };
      this.images = [...this.DOM.el.querySelectorAll('.content__img')].map(img => new ImageItem(img));
      this.imagesTotal = this.images.length; this.imgPosition = 0; this.zIndexVal = 1; this.isIdle = true;
      this.threshold = 90; this.minDelay  = 220; this._lastShownAt = 0;
      this.mousePos = { x:0, y:0 }; this.lastMousePos = { x:0, y:0 }; this.cacheMousePos = { x:0, y:0 };
      const handlePointerMove = ev => { const rect = this.container.getBoundingClientRect(); this.mousePos = getLocalPointerPos(ev, rect); };
      container.addEventListener('mousemove', handlePointerMove); container.addEventListener('touchmove', handlePointerMove);
      const initRender = ev => {
        const rect = this.container.getBoundingClientRect(); this.mousePos = getLocalPointerPos(ev, rect); this.cacheMousePos = { ...this.mousePos };
        requestAnimationFrame(() => this.render()); container.removeEventListener('mousemove', initRender); container.removeEventListener('touchmove', initRender);
      };
      container.addEventListener('mousemove', initRender); container.addEventListener('touchmove', initRender);
    }
    render(){
      const distance = getMouseDistance(this.mousePos, this.lastMousePos);
      this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1); this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);
      const now = performance.now();
      if (distance > this.threshold && (now - this._lastShownAt) > this.minDelay){
        this.showNextImage(); this.lastMousePos = { ...this.mousePos }; this._lastShownAt = now;
      }
      requestAnimationFrame(() => this.render());
    }
    showNextImage(){
      ++this.zIndexVal; this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
      const img = this.images[this.imgPosition];
      if (typeof gsap === 'undefined') return; // Added gsap check
      gsap.killTweensOf(img.DOM.el);
      gsap.timeline()
        .fromTo(img.DOM.el, { opacity: 1, scale: 1, zIndex: this.zIndexVal, x: this.cacheMousePos.x - img.rect.width/2, y: this.cacheMousePos.y - img.rect.height/2 },
          { duration: 0.6, ease: 'power1', x: this.mousePos.x - img.rect.width/2, y: this.mousePos.y - img.rect.height/2 }, 0)
        .to(img.DOM.el, { duration: 0.6, ease: 'power3', opacity: 0, scale: 0.2 }, 0.6);
    }
  }
  const variantMap = { 1: ImageTrailVariant1 };
  function ImageTrail({ items=[], variant=1 }){
    const containerRef = useRef(null);
    useEffect(() => {
      if(!containerRef.current) return;
      const Cls = variantMap[variant] || variantMap[1];
      new Cls(containerRef.current);
    }, [variant, items]);
    return (<div className="content" ref={containerRef}>{items.map((it, i) => { const src = typeof it === 'string' ? it : it.src;
          return (<div className="content__img" key={i}><img className="content__img-inner" src={src} alt="" decoding="async" onError={(e)=>{ e.currentTarget.parentElement.style.display='none'; }} /></div>);
        })}</div>);
  }

  /* ===== React Flowing Menu (exploreì™€ ë™ì¼ êµ¬ì¡°/ê°€ë“œ) ===== */
  function FlowingMenu({ items = [] }) {
    useEffect(() => { items.forEach(item => { if (item.image) { const img = new Image(); img.src = item.image; } }); }, [items]);
    return (<div className="fm-menu-wrap"><nav className="fm-menu" aria-label="Hamburger items">{items.map((it, i) => <MenuItem key={i} {...it} />)}</nav></div>);
  }
  function MenuItem({ link = '#', text, image }) {
    const itemRef = useRef(null); const marqueeRef = useRef(null); const marqueeInnerRef = useRef(null);
    const animationDefaults = { duration: 0.6, ease: 'expo.out' };
    const dist = (x,y,x2,y2)=>{ const dx=x-x2, dy=y-y2; return dx*dx+dy*dy; };
    const closestEdge = (mx,my,w,h)=> dist(mx,my,w/2,0) < dist(mx,my,w/2,h) ? 'top':'bottom';
    const enter = (ev)=>{
      if (typeof gsap === 'undefined') return;
      if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return; const rect = itemRef.current.getBoundingClientRect();
      const x=(ev.clientX??0)-rect.left, y=(ev.clientY??0)-rect.top; const edge=closestEdge(x,y,rect.width,rect.height);
      gsap.timeline({ defaults: animationDefaults }).set(marqueeRef.current,{ y:edge==='top' ? '-101%':'101%' },0).set(marqueeInnerRef.current,{ y:edge==='top' ? '101%':'-101%' },0).to([marqueeRef.current,marqueeInnerRef.current],{ y:'0%' },0);
    };
    const leave = (ev)=>{
      if (typeof gsap === 'undefined') return;
      if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return; const rect=itemRef.current.getBoundingClientRect();
      const x=(ev.clientX??0)-rect.left, y=(ev.clientY??0)-rect.top; const edge=closestEdge(x,y,rect.width,rect.height);
      gsap.timeline({ defaults: animationDefaults }).to(marqueeRef.current,{ y:edge==='top' ? '-101%':'101%' },0).to(marqueeInnerRef.current,{ y:edge==='top' ? '101%':'-101%' },0);
    };
    const onClick = () => { if (link && link.startsWith('#')) { if (window.toggleMenu) window.toggleMenu(false); } };
    const repeated = Array.from({ length:4 }).map((_,i)=>( <React.Fragment key={i}><span>{text}</span><div className="fm-marquee__img" style={{ backgroundImage:`url(${image})` }} /></React.Fragment> ));
    return (<div className="fm-menu__item" ref={itemRef}>
        <a className="fm-menu__item-link" href={link} onPointerEnter={enter} onPointerLeave={leave} onFocus={enter} onBlur={leave} onClick={onClick}>{text}</a>
        <div className="fm-marquee" ref={marqueeRef} aria-hidden="true"><div className="fm-marquee__inner-wrap" ref={marqueeInnerRef}><div className="fm-marquee__inner">{repeated}</div></div></div>
      </div>);
  }

  /* ===== Mount React bits ===== */
  (async () => {
    // ImageTrail mount
    const trailRoot = document.getElementById('image-trail-root');
    if (trailRoot) {
      const box = document.getElementById('trail-srcs'); const requested = box ? Array.from(box.querySelectorAll('img')).map(el => el.getAttribute('src')).filter(Boolean) : [];
      const testLoad = (url) => new Promise((res) => { const im = new Image(); im.onload  = () => res(url); im.onerror = () => res(null); im.src = url; });
      const results = await Promise.allSettled(requested.map(testLoad));
      const ok = results.map(r => (r.status==='fulfilled' ? r.value : null)).filter(Boolean);
      const fallback = ['img/gong/back/5.png','img/gong/back/a1.png','img/gong/b.png', /* Add more fallbacks if needed */ ];
      const usable = (ok.length ? ok : fallback).map(src => ({ src })); const variant = box?.dataset?.variant ? parseInt(box.dataset.variant, 10) : 1;
      if (ReactDOM.createRoot) {
         ReactDOM.createRoot(trailRoot).render(<ImageTrail items={usable} variant={variant} />);
      } else {
         ReactDOM.render(React.createElement(ImageTrail, { items: usable, variant: variant }), trailRoot);
      }
    }

    // FlowingMenu mount (explore ìŠ¤íƒ€ì¼, ì¤‘ë³µ ë§ˆìš´íŠ¸ ê°€ë“œ)
    const menuRoot = document.getElementById('react-menu-root');
    if (menuRoot && !menuRoot.__mounted) {
      menuRoot.__mounted = true;
      const menuItems = [
                    { link: 'ceramics.html',    text: 'ê³µì˜ˆí’ˆ',   image: 'img/gong/do.png' },
                    { link: 'sumak.html',     text: 'ìˆ˜ë§‰ìƒˆ', image: 'img/6.jpg' },
                    { link: 'hanbok.html', text: 'í•œë³µ', image: 'img/han/bg.jpg' },
                    { link: 'card.html',   text: 'ë¶€ì ', image: 'img/8.jpg' },
      ];
      if (ReactDOM.createRoot) {
        ReactDOM.createRoot(menuRoot).render(<FlowingMenu items={menuItems} />);
      } else {
        ReactDOM.render(React.createElement(FlowingMenu, { items: menuItems }), menuRoot);
      }
    }
  })();
</script>

<script>
  /* ===== Menu open/close ===== */
  (() => {
    const btn = document.getElementById('menuBtn');
    const overlay = document.getElementById('menuOverlay');
    const panel = document.getElementById('menuPanel');
    if(!btn || !overlay || !panel) return;
    function setOpen(open){
      btn.setAttribute('aria-expanded', String(open));
      overlay.classList.toggle('open', open);
      overlay.setAttribute('aria-hidden', String(!open));
      if (window.__lenis){ open ? window.__lenis.stop() : window.__lenis.start(); }
      else { document.body.style.overflow = open ? 'hidden' : ''; }
    }
    btn.addEventListener('click', () => setOpen(btn.getAttribute('aria-expanded') !== 'true'));
    overlay.addEventListener('click', () => setOpen(false));
    panel?.addEventListener('click', (e) => e.stopPropagation());
    window.addEventListener('keydown', (e) => { if(e.key === 'Escape') setOpen(false); });
    window.toggleMenu = function(next){ if (typeof next === 'boolean') setOpen(next); else setOpen(btn.getAttribute('aria-expanded') !== 'true'); };
  })();

  /* ===== Fit hero title ===== */
  document.addEventListener('DOMContentLoaded', () => {
    document.documentElement.classList.add('js');
    function fitHeroTitle(){
      const hero  = document.getElementById('hero');
      const title = document.getElementById('heroTitle');
      if(!hero || !title) return;
      title.style.transform = 'none'; // Reset transform before measuring
      const W_MARGIN = 1.0, H_MARGIN = 0.98;
      const cs   = getComputedStyle(hero);
      // Ensure clientWidth/Height are positive before calculations
      const heroClientWidth = Math.max(0, hero.clientWidth);
      const heroClientHeight = Math.max(0, hero.clientHeight);
      const wMax = (heroClientWidth  - (parseFloat(cs.paddingLeft)||0) - (parseFloat(cs.paddingRight)||0)) * W_MARGIN;
      const hMax = (heroClientHeight - (parseFloat(cs.paddingTop)||0)  - (parseFloat(cs.paddingBottom)||0)) * H_MARGIN;
      const rect = title.getBoundingClientRect();
      // Ensure rect dimensions are positive
      const rectWidth = Math.max(1, rect.width); // Avoid division by zero
      const rectHeight = Math.max(1, rect.height);
      const scale = Math.min(1, wMax/rectWidth, hMax/rectHeight);
      title.style.transformOrigin = 'center';
      title.style.transform = `scale(${scale})`;
    }
    // Use requestAnimationFrame for initial call after fonts ready
    (document.fonts?.ready || Promise.resolve()).then(() => { requestAnimationFrame(() => { fitHeroTitle(); }); });
    window.addEventListener('resize', fitHeroTitle);
  });

  /* ===== Lenis smooth scroll ===== */
  /* const lenis = new Lenis({ lerp: 0.09, smoothWheel: true, normalizeWheel: true });
  function raf(time){ lenis.raf(time); requestAnimationFrame(raf); }
  requestAnimationFrame(raf);
  window.__lenis = lenis;
*/

  /* =============================================================
    [ìˆ˜ì • 1] Interlude text progressive reveal
    - render í•¨ìˆ˜ê°€ window.__OVERVIEW_ANIM_DISABLED í”Œë˜ê·¸ë¥¼ í™•ì¸.
    - í”Œë˜ê·¸ê°€ trueì´ê±°ë‚˜ ì• ë‹ˆë©”ì´ì…˜ì´ 100% ì™„ë£Œë˜ë©´,
    - ë¦¬ìŠ¤ë„ˆë¥¼ ìŠ¤ìŠ¤ë¡œ ì œê±°í•˜ì—¬ ë” ì´ìƒ ì‹¤í–‰ë˜ì§€ ì•Šë„ë¡ ìˆ˜ì •.
  =============================================================
  */
  (function () {
    const section = document.getElementById('overview');
    const p = document.getElementById('interlude-desc');
    if (!section || !p) return;
    const raw = p.textContent;
    const text = (raw || '').replace(/\s+/g, ' ').trim();
    if (!text) return;
    const words = text.split(' ');
    p.textContent = ''; // Clear original text
    const spans = words.map((w) => {
      const s = document.createElement('span');
      s.className = 'w';
      s.textContent = w;
      p.appendChild(s);
      return s;
    });
    function pinProgress() {
      const rect = section.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const denom = rect.height - vh;
      if (denom <= 0) return 1; // Return 1 if section is shorter than viewport
      return Math.max(0, Math.min(1, (0 - rect.top) / denom));
    }
    
    // ğŸ’¡ 1: ê¸°ì¡´ render í•¨ìˆ˜ ì´ë¦„ì„ 'overviewTextRender'ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
    function overviewTextRender() {

      // ğŸ’¡ 2: ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™” í”Œë˜ê·¸ë¥¼ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€
      if (window.__OVERVIEW_ANIM_DISABLED === true) {
        spans.forEach((el) => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
        // ë¦¬ìŠ¤ë„ˆë¥¼ ì œê±°í•˜ì—¬ ìŠ¤í¬ë¡¤ ì‹œ ë‹¤ì‹œ ì‹¤í–‰ë˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
        removeEventListener('scroll', overviewTextRender);
        removeEventListener('resize', overviewTextRender);
        return;
      }

      const prog = pinProgress();
      const N = spans.length;
      for (let i = 0; i < N; i++) {
        const t = (i + 1) / (N + 1); // Stagger threshold for each word
        const a = Math.max(0, Math.min(1, (prog - t) / 0.12)); // Animation progress for word i
        const op = 1 - Math.pow(1 - a, 3); // Eased opacity
        const ty = (1 - op) * 16; // Eased translation
        const el = spans[i];
        el.style.opacity = op.toFixed(3);
        el.style.transform = `translateY(${ty.toFixed(2)}px)`;
      }
      
      // ğŸ’¡ 3: ì• ë‹ˆë©”ì´ì…˜ì´ ìì—°ì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆì„ ë•Œë„ ë¦¬ìŠ¤ë„ˆë¥¼ ì œê±°í•©ë‹ˆë‹¤.
      if (prog >= 1) {
        spans.forEach((el) => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
        // ë¦¬ìŠ¤ë„ˆ ì œê±°
        removeEventListener('scroll', overviewTextRender);
        removeEventListener('resize', overviewTextRender);
      }
    }
    
    // ğŸ’¡ 4: 'render' ëŒ€ì‹  ë³€ê²½ëœ í•¨ìˆ˜ ì´ë¦„('overviewTextRender')ìœ¼ë¡œ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
    addEventListener('scroll', overviewTextRender, { passive: true });
    addEventListener('resize', overviewTextRender); // Re-render on resize
    requestAnimationFrame(overviewTextRender); // Initial render
  })();


  /* ===== Interlude circle parallax/scale ===== */
  (function(){
    const sec = document.getElementById('overview');
    const img = document.getElementById('circleImg');
    if(!sec || !img) return;
    function progress(){
      const rect = sec.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const denom = rect.height - vh;
      if (denom <= 0) return 1; // If shorter than viewport, progress is 1
      return Math.max(0, Math.min(1, (0 - rect.top) / denom)); // Clamp progress 0-1
    }
    function render(){
      const p = progress();
      const s = 1 + 0.12*p; // Scale from 1 to 1.12
      const ty = - (window.innerHeight * 0.06) * p; // Translate up slightly
      img.style.transform = `translateY(${ty}px) scale(${s})`;
    }
    addEventListener('scroll', render, { passive:true }); // Use passive listener
    addEventListener('resize', render); // Update on resize
    requestAnimationFrame(render); // Initial render
  })();




/* ===== Horizontal panels: improved stable one-by-one opening ===== */
(() => {
  const sec   = document.getElementById('crafts-hscroll');
  const track = document.getElementById('crafts-track');
  if (!sec || !track) return;

  const panels = Array.from(track.querySelectorAll('.panel'));
  const count  = panels.length;
  if (count === 0) return; // Exit if no panels

  document.documentElement.style.setProperty('--panels', String(count));

  const steps = Math.max(1, count - 1); // index range 0..steps
  const vh    = () => window.innerHeight || document.documentElement.clientHeight;

  /* ---- Calculate progress (0-1) ---- */
  function progress(){
    const r = sec.getBoundingClientRect();
    const denom = r.height - vh();
    if (denom <= 0) return 0; // Avoid division by zero or negative values
    return Math.max(0, Math.min(1, (0 - r.top) / denom)); // Clamp 0-1
  }

  /* ---- Calculate target index from progress ---- */
  function idxFromProgress(p){
    const clamped = Math.max(0, Math.min(1, p));
    return Math.round(clamped * steps); // Round to nearest index
  }

  /* ---- Check if section is pinned in viewport ---- */
  let pinnedSince = null;
  function inPinnedView(){
    const r = sec.getBoundingClientRect();
    const pinned = r.top <= 0 && r.bottom >= vh();
    if (pinned && pinnedSince === null) pinnedSince = Date.now(); // Record when pinning started
    if (!pinned) pinnedSince = null; // Reset when not pinned
    return pinned;
  }

  /* ---- State variables ---- */
  let activeIdx   = 0;
  let openTimer   = null;
  let idleTimer   = null;
  let isSnapping  = false;  // Lock during snap animation
  let lastSnapAt  = 0;      // Timestamp of last snap start
  let lastRaw     = 0;      // Last raw progress (0..steps)
  let userInteracted = false; // Track if user has scrolled/touched etc.
  let lastScrollTime = 0;   // Timestamp of last scroll event

  const FLEX_DUR_MS       = 1100; // Panel opening duration (matches CSS)
  const IDLE_DELAY_MS     = 650;  // Delay before snapping after scroll stops
  const IDLE_COOLDOWN_MS  = 600;  // Cooldown after a snap to prevent immediate re-snap
  const RAW_HYSTERESIS    = 0.55; // Threshold to move to next/prev panel

  /* ---- Set active panel (expand and show content) ---- */
  function setActive(idx, opts = { preserveIfSame:true }) {
    const target = Math.max(0, Math.min(steps, idx)); // Clamp index
    if (opts.preserveIfSame && target === activeIdx) return; // No change needed

    activeIdx = target;

    // Reset other panels
    panels.forEach((el, i) => {
      if (i !== activeIdx) el.classList.remove('is-active', 'is-open', 'show-footer');
    });

    // Activate the target panel
    const activePanel = panels[activeIdx];
    if (activePanel) activePanel.classList.add('is-active');

    // Show content after flex animation completes
    clearTimeout(openTimer);
    openTimer = setTimeout(() => {
      const currentPanel = panels[activeIdx];
      if (!currentPanel) return;
      currentPanel.classList.add('is-open');
      currentPanel.classList.add('show-footer'); // Add class to show footer
    }, FLEX_DUR_MS);
  }

  /* ---- Smooth scroll to a specific index (vertical snap) ---- */
  const easing = t => 1 - Math.pow(1 - t, 4); // Ease-out quart
  function snapToIndex(idx){
    const i = Math.max(0, Math.min(steps, idx)); // Clamp index
    const r = sec.getBoundingClientRect();
    const sectionTop = window.scrollY + r.top;
    const denom = r.height - vh();
    if (denom <= 0) return; // Cannot snap if section height <= viewport height

    const targetY = sectionTop + denom * (i / steps); // Calculate target scroll position

    isSnapping = true;
    lastSnapAt = Date.now();

    if (window.__lenis && typeof window.__lenis.scrollTo === 'function'){
      // Use Lenis if available
      window.__lenis.scrollTo(targetY, { duration: 1.05, easing });
    } else {
      // Use native smooth scroll otherwise
      window.scrollTo({ top: targetY, behavior: 'smooth' });
    }

    // Unlock after a delay (slightly shorter than animation duration)
    setTimeout(() => { isSnapping = false; }, 900);
  }

  /* ---- Snap logic based on scroll progress when idle ---- */
  function idleSnap(){
    // Only snap if pinned, not already snapping, and enough time has passed since last snap
    if (!inPinnedView() || isSnapping || (Date.now() - lastSnapAt < IDLE_COOLDOWN_MS)) return;

    const p   = progress();
    const raw = p * steps; // Raw progress (0..steps)
    const diffFromActive = Math.abs(raw - activeIdx); // How far from current active center

    // Prevent auto-snap immediately on entering view unless user interacts or waits
    if (!userInteracted) {
      if (!pinnedSince || (Date.now() - pinnedSince) < 600) {
        lastRaw = raw; // Update state but don't snap yet
        return;
      }
    }

    // Ignore tiny scroll changes (jitter reduction)
    if (Math.abs(raw - lastRaw) < 0.12) {
      lastRaw = raw;
      return;
    }

    // If scrolled far enough from the center, snap to the new target
    if (diffFromActive >= RAW_HYSTERESIS) {
      const target = idxFromProgress(p);
      if (target !== activeIdx) {
        setActive(target, { preserveIfSame:false });
        snapToIndex(target);
      }
    } else {
      // If not far enough, snap back to the current active index (optional, can be removed)
      // snapToIndex(activeIdx);
    }

    lastRaw = raw; // Update last raw position
  }

  // Debounced call to idleSnap after scrolling stops
  function scheduleIdleSnap(){
    clearTimeout(idleTimer);
    idleTimer = setTimeout(idleSnap, IDLE_DELAY_MS);
  }

  /* ---- Initialization ---- */
  setActive(0, { preserveIfSame:false }); // Activate first panel initially
  lastRaw = progress() * steps; // Set initial raw progress
  if (inPinnedView()) pinnedSince = Date.now(); // Check if already pinned on load

  /* ---- Event Listeners ---- */

  // Wheel event for step-by-step navigation
  let wheelAccum = 0;
  let lastWheelAt = 0;
  let lastWheelSign = 0;
  const WHEEL_STEP_THRESHOLD = 120; // Accumulation needed for one step
  const WHEEL_COOLDOWN       = 550; // Cooldown between wheel steps

  window.addEventListener('wheel', (e)=>{
    if (!inPinnedView()) return; // Only act when pinned

    userInteracted = true; // Mark interaction
    lastScrollTime = Date.now(); // Track last scroll activity

    if (isSnapping) { e.preventDefault(); return; } // Prevent interference during snap

    const now = Date.now();
    const dy  = e.deltaY || 0;
    const sign = Math.sign(dy);

    // Reset accumulator if direction changes
    if (sign !== 0 && sign !== lastWheelSign) wheelAccum = 0;
    lastWheelSign = sign;
    wheelAccum += dy;

    // Check if threshold and cooldown are met
    const ready = Math.abs(wheelAccum) >= WHEEL_STEP_THRESHOLD && (now - lastWheelAt) >= WHEEL_COOLDOWN;
    if (ready){
      e.preventDefault(); // Prevent default page scroll
      const next = activeIdx + (wheelAccum > 0 ? 1 : -1); // Calculate next index
      wheelAccum = 0; // Reset accumulator
      lastWheelAt = now; // Update timestamp

      setActive(next, { preserveIfSame:false }); // Set new active panel
      snapToIndex(next); // Snap to it
    } else {
      scheduleIdleSnap(); // If not ready, just schedule idle check
    }
  }, { passive:false }); // Use active listener to allow preventDefault

  // Touch swipe events
  let touchStartY = null;
  sec.addEventListener('touchstart', e => { touchStartY = e.touches[0].clientY; userInteracted = true; }, { passive:true });
  sec.addEventListener('touchend', e => {
    if (!inPinnedView() || touchStartY == null) return;
    const dy = (e.changedTouches[0].clientY - touchStartY);
    touchStartY = null; // Reset start position

    if (Math.abs(dy) > 70) { // Swipe threshold
      const next = activeIdx + (dy < 0 ? 1 : -1); // Determine direction
      setActive(next, { preserveIfSame:false });
      snapToIndex(next);
    } else {
      scheduleIdleSnap(); // If not a significant swipe, schedule idle check
    }
  }, { passive:true });

  // Mark interaction on pointer/key events
  window.addEventListener('pointerdown', () => { userInteracted = true; }, { passive:true });
  window.addEventListener('keydown', () => { userInteracted = true; }, { passive:true });

  // Schedule idle snap check on scroll and resize events
  window.addEventListener('scroll', () => { lastScrollTime = Date.now(); if (inPinnedView()) scheduleIdleSnap(); }, { passive:true });
  window.addEventListener('resize', () => { if (inPinnedView()) scheduleIdleSnap(); });

})();

  // Back button event listener removed
//* ===== interlude-desc ì™„ì „ ë…¸ì¶œ ì‹œ circleImg ì–´ë‘¡ê²Œ + í…ìŠ¤íŠ¸ í‘œì‹œ ===== */
(function(){
  const section = document.getElementById('overview');
  const circleHero = document.querySelector('.circle-hero');
  if (!section || !circleHero) return;

  // ì´ˆê¸°ì—ëŠ” í•„í„°ì™€ í…ìŠ¤íŠ¸ ë‘˜ ë‹¤ ìˆ¨ê¹€
  circleHero.style.setProperty('--overlay-opacity', '0');
  circleHero.style.setProperty('--hint-opacity', '0');

  // ::before, ::after opacityë¥¼ JSì—ì„œ ì œì–´í•˜ê¸° ìœ„í•œ CSS ë³€ìˆ˜ ì¶”ê°€
  const style = document.createElement('style');
  style.textContent = `
    .circle-hero::before {
      opacity: var(--overlay-opacity, 0);
      transition: opacity 0.6s ease;
    }
    .circle-hero::after {
      opacity: var(--hint-opacity, 0);
      transition: opacity 0.6s ease;
    }
  `;
  document.head.appendChild(style);

  // interlude-desc ìŠ¤í¬ë¡¤ ì§„í–‰ë¥  ê³„ì‚°
  function getProgress(){
    const rect = section.getBoundingClientRect();
    const vh = window.innerHeight || document.documentElement.clientHeight;
    const denom = rect.height - vh;
    if (denom <= 0) return 1;
    return Math.max(0, Math.min(1, (0 - rect.top) / denom));
  }

  function onScroll(){
    const p = getProgress();
    // interlude-descê°€ ì „ë¶€ ë‹¤ ì˜¬ë¼ì™”ì„ ë•Œ(0.9 ì´ìƒ) ì˜¤ë²„ë ˆì´+í…ìŠ¤íŠ¸ í‘œì‹œ
    const show = p > 0.9;
    circleHero.style.setProperty('--overlay-opacity', show ? '1' : '0');
    circleHero.style.setProperty('--hint-opacity', show ? '1' : '0');
  }

  addEventListener('scroll', onScroll, { passive:true });
  addEventListener('resize', onScroll);
  requestAnimationFrame(onScroll);
})();


/* =============================================================
  [ìˆ˜ì • 3] #overviewë¡œ ëŒì•„ì™”ì„ ë•Œ
  - í…ìŠ¤íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™”
  - í…ìŠ¤íŠ¸/ì˜¤ë²„ë ˆì´ ì¦‰ì‹œ í‘œì‹œ
  - ë¶€ë“œëŸ½ê²Œ í•´ë‹¹ ìœ„ì¹˜ë¡œ ìŠ¤í¬ë¡¤
  - ìŠ¤í¬ë¡¤ ìœ ë„ ì˜¤ë²„ë ˆì´ ë° í…ìŠ¤íŠ¸ í‘œì‹œ (NEW)
=============================================================
*/
window.addEventListener("load", () => {
  // URL í•´ì‹œê°€ #overviewì¸ ê²½ìš°
  if (window.location.hash === "#overview") {
    
    // 1. í…ìŠ¤íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™” í”Œë˜ê·¸ ì„¤ì •
    window.__OVERVIEW_ANIM_DISABLED = true;

    const desc = document.getElementById("interlude-desc");
    const circleHero = document.querySelector(".circle-hero");

    // 2. í…ìŠ¤íŠ¸ ì¦‰ì‹œ í‘œì‹œ
    if (desc) {
      const spans = desc.querySelectorAll(".w");
      if (spans.length > 0) {
          spans.forEach((el) => {
            el.style.opacity = "1";
            el.style.transform = "translateY(0)";
          });
      }
    }

    // 3. circle ì´ë¯¸ì§€ ì˜¤ë²„ë ˆì´ì™€ ì•ˆë‚´ë¬¸êµ¬ í‘œì‹œ
    if (circleHero) {
      circleHero.style.setProperty("--overlay-opacity", "1");
      circleHero.style.setProperty("--hint-opacity", "1");
    }

    // 4. interlude ì„¹ì…˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ìŠ¤í¬ë¡¤ (300ms ì†Œìš”)
    setTimeout(() => {
      const target = document.querySelector("#overview");
      if (target) target.scrollIntoView({ behavior: "smooth" });

      // 5. [ì‹ ê·œ] ìŠ¤í¬ë¡¤ ì´ë™ì´ ëë‚œ í›„(300ms + 200ms ë²„í¼) 
      //    ìŠ¤í¬ë¡¤ ìœ ë„ ì˜¤ë²„ë ˆì´ í‘œì‹œ
      setTimeout(showScrollHint, 500);

    }, 300);


    // 6. [ì‹ ê·œ] ìŠ¤í¬ë¡¤ ìœ ë„ ì˜¤ë²„ë ˆì´ë¥¼ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
    function showScrollHint() {
      // 6-1. ìŠ¤íƒ€ì¼ ì£¼ì… (ì¤‘ë³µ ë°©ì§€)
      if (!document.getElementById('scroll-hint-styles')) {
        const style = document.createElement('style');
        style.id = 'scroll-hint-styles';
        style.textContent = `
          .scroll-hint-overlay {
            position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.8);
            z-index: 9998; opacity: 0; transition: opacity 0.5s ease;
            pointer-events: none;
          }
          .scroll-hint-text {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: 'Suit', sans-serif;
            font-size: 22px; font-weight: 600;
            padding: 16px 24px; background: rgba(0, 0, 0, 0.3);
            border-radius: 12px; z-index: 9999; opacity: 0;
            transition: opacity 0.5s ease; pointer-events: none;
            text-align: center; white-space: nowrap;
          }
          .scroll-hint-overlay.show, .scroll-hint-text.show {
            opacity: 1; pointer-events: auto;
          }
        `;
        document.head.appendChild(style);
      }

      // 6-2. HTML ìš”ì†Œ ìƒì„±
      const overlay = document.createElement('div');
      overlay.className = 'scroll-hint-overlay';

      const hintText = document.createElement('div');
      hintText.className = 'scroll-hint-text';
      hintText.textContent = 'ìŠ¤í¬ë¡¤ì„ ë‚´ë ¤ë³´ì„¸ìš”.';

      document.body.appendChild(overlay);
      document.body.appendChild(hintText);

      // 6-3. í˜ì´ë“œì¸
      requestAnimationFrame(() => {
        overlay.classList.add('show');
        hintText.classList.add('show');
      });

      // 6-4. ìŠ¤í¬ë¡¤ ì‹œ ì œê±°í•˜ëŠ” í•¨ìˆ˜
      const removeHint = () => {
        overlay.classList.remove('show');
        hintText.classList.remove('show');
        
        // íŠ¸ëœì§€ì…˜(0.5s) ì™„ë£Œ í›„ DOMì—ì„œ ì œê±°
        setTimeout(() => {
          overlay.remove();
          hintText.remove();
        }, 500); 
        
        // ë¦¬ìŠ¤ë„ˆ ì œê±°
        window.removeEventListener('scroll', removeHint);
        window.removeEventListener('wheel', removeHint);
        window.removeEventListener('touchmove', removeHint);
      };

      // 6-5. ìŠ¤í¬ë¡¤, íœ , í„°ì¹˜ ì´ë²¤íŠ¸ì— ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (í•œ ë²ˆë§Œ ì‹¤í–‰)
      window.addEventListener('scroll', removeHint, { once: true, passive: true });
      window.addEventListener('wheel', removeHint, { once: true, passive: true });
      window.addEventListener('touchmove', removeHint, { once: true, passive: true });
    }
  }
});

</script>

</body>
</html>