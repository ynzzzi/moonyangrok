<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CRAFT WORK</title>

<script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script defer src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://unpkg.com/@studio-freight/lenis/dist/lenis.min.js"></script>

<style>
  /* ===== Fonts ===== */
  @font-face {
    font-family: 'Suit';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_suit@1.0/SUIT-Light.woff2') format('woff2');
    font-weight: 300; font-display: swap;
  }
  @font-face {
    font-family: 'BookkMyungjo';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkMyungjo-Lt.woff2') format('woff2');
    font-weight: 400; font-display: swap;
  }
  @font-face {
    font-family: 'BookkGothic';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkGothic-Bd.woff2') format('woff2');
    font-weight: 700; font-display: swap;
  }

  :root{
    --ink:#0a0a0a;
    --muted:#6b7280;
    --gutter: clamp(16px, 4vw, 48px);
    --z-header: 100;
    --z-overlay: 90;
    --hero-bg:#ffffff;
    --panels: 3;
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  html{ scroll-behavior:auto; }
  body{
    margin:0; color:var(--ink); background:var(--hero-bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
    line-height:1.45; overflow-x:hidden;
    background-color: #f0f0f0;
  }

  /* ===== Header / Menu ===== */
  .site-header{
    position: fixed; inset: 0 0 auto 0; height: 64px; z-index: var(--z-header);
    display: grid; grid-template-columns: 1fr 1fr; align-items: center;
    padding: 8px var(--gutter); pointer-events: none;
  }

  /* 헤더(홈/메뉴 아이콘)를 화면 상단에서 ↓로 조금 내리기 */
.site-header{
  top: 18px !important;   /* ← 내려가는 양: 12~28px 사이로 취향 조절 */
  left: 0;
  right: 0;
}

/* 아이콘을 조금 더 여유 있게 보이고 싶으면 버튼 자체도 살짝 내리기(옵션) */
.site-header .icon-btn{
  transform: translateY(2px); /* 0~6px 사이로 조절 */
}
  .header-left{ justify-self: start; }
  .header-right{ justify-self: end; }
  .icon-btn{
    pointer-events: auto; appearance: none; border: 0; background: transparent; cursor: pointer;
    width: 44px; height: 44px; display: inline-grid; place-items: center;
    border-radius: 999px; transition: background .2s ease;
  }
  .icon-btn:hover{ background: rgba(0,0,0,.06); }
  .icon-btn:focus-visible{ outline: 2px solid #111; outline-offset: 2px; }
  .home-svg{ width: 22px; height: 22px; fill:none; stroke:#111; stroke-width:2; }
  .menu-btn .burger{ display:grid; gap:4px; }
  .menu-btn .burger span{ width:20px; height:2px; background:#111; display:block; transition: transform .25s, opacity .25s; }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(2){ opacity:0; }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(1){ transform: translateY(6px) rotate(45deg); }
  .menu-btn[aria-expanded="true"] .burger span:nth-child(3){ transform: translateY(-6px) rotate(-45deg); }
  .hm-overlay{ position: fixed; inset:0; background: rgba(0,0,0,.35); display:none; z-index: var(--z-overlay); }
  .hm-overlay.open{ display:grid; place-items: stretch; }
  .hm-panel{
    margin-left:auto; width:min(500px, 90vw); height:100%;
    background:#060010; color:#fff; position:relative;
    transform: translateX(100%); transition: transform .45s cubic-bezier(.19,1,.22,1);
    box-shadow: -12px 0 24px rgba(0,0,0,.25);
  }
  .hm-overlay.open .hm-panel{ transform: translateX(0); }
  #react-menu-root{ height:100%; }
  .fm-menu-wrap{ width:100%; height:100%; overflow:hidden; background:#060010; }
  .fm-menu{ display:flex; flex-direction:column; height:100%; margin:0; padding:0;    grid-template-rows: repeat(4, 1fr);   justify-content: space-evenly; }
  .fm-menu__item{  position: relative;
  overflow: hidden;
  text-align: center;
  box-shadow: 0 -1px var(--fm-divider);
  display: grid;
  place-items: center; /* 수직/수평 중앙 */
  height: 100%;
  min-height: unset;   /* 높이 강제값 해제(큰 화면에서 상단 치우침 방지) */}
.menu-items { height: 100%; }
  .fm-menu__item-link{
  display: grid;
  place-items: center;
  width: 100%;
  height: 100%;
  cursor: pointer;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  font-weight: 600;
  color: var(--fm-fg);
  font-size: clamp(18px, 4vh, 42px);
  outline: none;
font-family:'BookkGothic';
      font-weight:600; color:#fff;
  }
  .fm-menu__item-link:focus-visible{ outline:2px solid #fff; outline-offset: -4px; }
  .fm-marquee{ position:absolute; inset:0; overflow:hidden; pointer-events:none; background:#fff;
    transform: translate3d(0,101%,0); transition: transform .6s cubic-bezier(.19,1,.22,1); }
  .fm-marquee__inner-wrap{ height:100%; width:200%; display:flex; transform:translateX(0); }
  .fm-marquee__inner{ display:flex; align-items:center; height:100%; width:200%; will-change:transform; animation: fm-marquee 15s linear infinite; }
  .fm-marquee span{ color:#060010; white-space:nowrap; text-transform:uppercase; font-weight:400;
    font-size:clamp(16px,4vh,36px); line-height:1.2; padding:1vh 1vw 0; }
  .fm-marquee__img{ width:200px; height:7vh; min-height:42px; margin:2em 2vw; padding:1em 0; border-radius:50px; background-size:cover; background-position:50% 50%; }
  @keyframes fm-marquee{ from{transform:translateX(0)} to{transform:translateX(-50%)} }

  /* ===== Hero + ImageTrail ===== */
  .hero{ position:relative; min-height:100svh; padding: clamp(12px, 2vw, 24px) var(--gutter) max(10vh, 64px);
    display:grid; align-items:center; justify-content:center; background:var(--hero-bg); overflow:hidden; }
  .hero-inner{ width:100%; text-align:center; position:relative; z-index:1; }
  .hero-title-wrap{ position:relative; display:inline-block; }
  .hero-title{ margin:0 auto; font-size: max(40vw, 78vh); line-height:.86; letter-spacing:-.02em; font-weight:900; color:#000;
    white-space:nowrap; display:inline-block; transform-origin:center; }
  .hero-desc{
    font-family: 'BookkMyungjo', serif; max-width:140ch; margin: clamp(16px, 2vh, 32px) auto 0;
    font-size: clamp(13px, 1.5vw, 16px); line-height: 1.9; color: #2b2b2b; letter-spacing: -0.01em;
  }
  .image-trail-layer{ position:absolute; inset:0; z-index:60; pointer-events:auto; }
  .content{ width:100%; height:100%; position:relative; z-index:60; background: transparent; overflow: visible; }
  .content__img { position: absolute; top: 0; left: 0; opacity: 0; overflow: hidden; will-change: transform, filter; border-radius: 15px; width: 190px; aspect-ratio: 1.1; }
  .content__img-inner { display: block; width: 100%; height: 100%; object-fit: contain; background: none !important; }

  /* ===== Interlude ===== */
  .interlude{ height: 350vh; padding: 0 var(--gutter); display:block; background:var(--hero-bg); border-block: 1px solid #e5e5dc; }
  .interlude--circle .interlude__wrap{ position: sticky; top: 0; min-height: 100svh; max-width: 1100px; margin: 0 auto;
    display:grid; place-content:center; justify-items:center; text-align:center; gap: 24px; padding: clamp(48px,  8vw, 120px) 0; }
  .interlude--circle .interlude__desc{ font-family: 'BookkMyungjo', serif; color:#2b2b2b; letter-spacing:-.01em; line-height:1.9;
    font-size: clamp(14px, 1.6vw, 18px); max-width: 72ch; margin: 0 auto; white-space: normal; }
  .interlude__desc .w{ display:inline-block; opacity:0; transform: translateY(16px); will-change: transform, opacity; margin-right:.28em; vertical-align:baseline; white-space:nowrap; }
  .circle-hero{ width: min(52vw, 440px); aspect-ratio: 16 / 10; border-radius: 9999px; overflow:hidden; display:grid; place-items:center; background:#f3f3eb; box-shadow: 0 12px 34px rgba(0,0,0,.08); will-change: transform; }
  .circle-hero img{ width:110%; height:110%; object-fit:cover; transform: translate3d(0,0,0) scale(1); transform-origin:50% 50%; will-change: transform; }

  /* ===== Horizontal Scroll Section Layout ===== */
  .hscroll-new {
    height: calc(var(--panels) * 100vh + 100vh);
    background-color: #f0f0f0;
    position: relative;
    z-index: 1;
  }
  .hscroll-sticky {
    position: sticky;
    top: 0;
    height: 100vh;
    overflow: hidden;
  }
  .hscroll-track {
    display: flex;
    height: 100vh;
    gap: 0;
  }
  .panel {
    border-left: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    justify-content: center;
    flex-basis: 0;
    flex-shrink: 0;
    flex-grow: 1;
    background: #fff;
    box-shadow: 0 12px 30px rgba(0,0,0,.04);
    transition: flex-grow 1.1s cubic-bezier(.22,.61,.36,1);
    height: 100vh;
    overflow: hidden;
  }
  .panel.is-active{
    box-shadow: 0 16px 48px rgba(0,0,0,.08);
  }

  .panel-content {
    display: flex;
    flex-direction: row;
    align-items: center;
    width: 100%;
    height: 100%;
    padding: 0 5vw;
    gap: 5vw;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity .6s ease, transform .6s ease;
    pointer-events: none;
  }
  .panel.is-open .panel-content {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
    transition-delay: .1s;
  }

  .panel-image-wrapper {
    flex: 1 1 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  .panel-image {
    width: 100%;
    height: auto;
    max-height: 60vh;
    object-fit: contain;
  }

  .panel-text-wrapper {
    flex: 1 1 45%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: #111;
  }

  .panel-header {
    display: flex;
    align-items: baseline;
    gap: 16px;
    border-bottom: 1px solid #e5e7eb;
    padding-bottom: 22px; /* Adjusted */
    margin-bottom: 44px;  /* Adjusted */
    width: 100%;
  }

  .panel-number {     font-family: 'BookkGothic';font-size: clamp(16px, 1.1vw, 22px); font-weight: 700; color: #94a3b8; transition: transform .45s ease; }
  .panel-title  {     font-family: 'BookkGothic';font-size: clamp(28px, 2.5vw, 42px); font-weight: 700; margin: 0; color:#111; transition: transform .45s ease; }
  .panel.is-open .panel-number,
  .panel.is-open .panel-title { transform: translateY(16px); } /* Adjusted */

  .panel-footer {
     font-size: 14px;
  }
  .panel-meta {
    text-transform: uppercase;
    color: #64748b;
    letter-spacing: .08em;
    font-size: clamp(12px, 0.9vw, 16px);
  }
  .panel-desc {
    margin-top: 16px;
    color: #374151;
    line-height: 1.8;
    font-family: 'Suit';
    font-size: clamp(15px, 1.0vw, 18px);
  }

  .panel:not(.is-active) {
    cursor: pointer;
  }
  .panel:not(.is-active) .panel-content {
    display: none;
  }
  .panel:not(.is-active) .panel-header-collapsed {
    display: flex;
    writing-mode: vertical-rl;

    align-items: center;
    justify-content: center;
    height: 100%;
    gap: 20px;
    opacity: 0.5;
    transition: opacity 0.3s ease;
  }
  .panel:not(.is-active):hover .panel-header-collapsed {
    opacity: 1;
  }
  .panel:not(.is-active) .panel-number,
  .panel:not(.is-active) .panel-title {
     font-size: clamp(20px, 1.6vw, 34px);
  }
 /* Adjusted */
  .panel:not(.is-active) .panel-header-collapsed .panel-number,
  .panel:not(.is-active) .panel-header-collapsed .panel-title {
    transform: translateY(6px);
  }

  .panel { flex: 1 0 0; }
  .panel.is-active { flex: 12 0 0; }

  @media (max-width: 1024px) {
    .panel { padding: 0 32px; justify-content: flex-start; }
    .panel-content { flex-direction: column; padding: 20px 0; gap: 20px; opacity: 0; transform: translateY(16px); pointer-events:none; }
    .panel.is-open .panel-content { opacity: 1; transform: none; pointer-events:auto; transition: opacity .45s ease .05s, transform .45s ease .05s; }
    .panel-image-wrapper, .panel-text-wrapper { flex-basis: auto; }
    .panel:not(.is-active) .panel-header-collapsed { display: none; }
    .panel:not(.is-active) .panel-header { display: flex; }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 20px 0 18px;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 0;
    }
     .panel-footer {
        padding-top: 8px;
        opacity: 0;
        transform: translateY(10px);
        max-height: 0;
        overflow: hidden;
        pointer-events: none;
        transition: opacity .35s ease, transform .35s ease, max-height .5s ease;
      }
      .panel.is-active .panel-footer {
        opacity: 1;
        transform: translateY(0);
        max-height: 50vh;
        overflow: auto;
        pointer-events: auto;
        transition-delay: .6s;
      }
  }


  /* ===== Gallery after ===== */
  .un-section{
    display:flex;
    justify-content:center;
    align-items:center;
    width:100%;
    padding:60px 0;
    background:var(--hero-bg);
    position: relative;
    z-index: 2;
  }
  .image-list{display:flex;flex-direction:column;align-items:center;gap:60px}
  .image-item{display:flex;flex-direction:column;align-items:center;width:460px}
  .image-item img{width:100%;height:auto;margin:0;transform:scale(1);transition:transform .35s cubic-bezier(.22,.61,.36,1)}
  .image-item img:hover{ transform: scale(1.05); }

  /* ===== 4K 대응 패치 ===== */
  :root{
    --gutter: clamp(16px, 3.5vw, 64px);
  }
  .content__img{
    width: clamp(140px, 10vw, 280px);
    border-radius: clamp(10px, 1vw, 18px);
  }
  .interlude--circle .interlude__desc{
    font-size: clamp(16px, 1.2vw, 22px);
  }
  .interlude--circle .interlude__wrap{
    max-width: min(1400px, 86vw);
  }
  .circle-hero{
    width: clamp(360px, 40vw, 720px);
  }

  .image-list{
    gap: clamp(40px, 6vh, 100px);
  }
  .image-item{
    width: clamp(280px, 24vw, 720px);
  }
  .image-item img{
    border-radius: clamp(8px, 0.8vw, 16px);
  }
  @media (min-width: 1600px){
    .site-header{ height: 72px; padding-inline: max(24px, 4vw); top: 20px; }
  }

  /* === 스크롤 멈춤 방지: hscroll 아래 여유 높이 추가 === */
.hscroll-new::after {
  content: "";
  display: block;
  height: 200vh; /* 추가 스크롤 여유 공간 */
}

/* 27인치 모니터 기준 (1600px 이상) */
@media (min-width: 1600px) {
  .interlude--circle .interlude__wrap {
    padding-top: 10vh;   /* 화면 상단으로부터 여백 */
    padding-bottom: 10vh; /* 아래쪽 균형 맞추기 */
    transform: translateY(3vh); /* 전체 콘텐츠를 아래로 살짝 이동 */
  }
}

@media (min-width: 1600px) {
  .interlude--circle .interlude__wrap {
    gap: 8vw; /* 기존보다 간격 넓힘 (기존이 4~5vw였다면 두 배 정도) */
  }

  /* 혹시 gap이 적용되지 않는 flex 구조라면 margin으로 대체 가능 */
  .interlude--circle .interlude__text {
    margin-right: 6vw; /* 텍스트와 이미지 사이 여유 */
  }
}

</style>
</head>
<body>

<header class="site-header" role="banner">
  <div class="header-left">
    <a class="icon-btn" href="index.html" aria-label="Home">
      <svg class="home-svg" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 10.5 12 3l9 7.5M5 9.5V21h14V9.5" />
      </svg>
    </a>
  </div>

  <div class="header-right">
    <button id="menuBtn" class="icon-btn menu-btn" type="button" aria-expanded="false" aria-controls="menuPanel" aria-label="Open menu">
      <span class="burger"><span></span><span></span><span></span></span>
    </button>
  </div>
</header>
<div id="menuOverlay" class="hm-overlay" aria-hidden="true">
  <aside id="menuPanel" class="hm-panel" role="dialog" aria-modal="true" aria-label="Navigation menu">
    <div class="menu-items"><div id="react-menu-root"></div></div>
  </aside>
</div>

<section class="hero" id="hero">
  <div class="hero-inner">
    <div class="image-trail-layer" id="image-trail-root">
      <div id="trail-srcs" data-variant="1" style="display:none">
        <img src="img/gong/back/5.png" alt=""> <img src="img/gong/back/a1.png" alt=""> <img src="img/gong/b.png" alt="">
        <img src="img/gong/back/ccc.png" alt=""> <img src="img/gong/ch.png" alt=""> <img src="img/gong/back/crafts.png" alt="">
        <img src="img/gong/back/cup.png" alt=""> <img src="img/gong/back/p.png" alt="">
      </div>
    </div>
    <div class="hero-title-wrap">
      <h1 class="hero-title" id="heroTitle">KOREAN&nbsp;&nbsp;&nbsp;CRAFTS*</h1>
    </div>
    <p class="hero-desc">
      우리나라의 전통공예품은 실용성과 예술성을 조화롭게 갖춘 생활 속의 예술입니다.<br />
      자연에서 얻은 재료로 오랜 시간 다듬고 정성껏 만든 공예품에는 조상들의 지혜와 미적 감각이 고스란히 담겨 있습니다.
    </p>
  </div>
</section>

<section class="interlude interlude--circle" id="overview">
  <div class="interlude__wrap">
    <p id="interlude-desc" class="interlude__desc">
      도자기는 흙으로 빚은 그릇을 구워내는 방법에 따라 토기(土器), 도기(陶器), 자기(瓷器)로 나누어지는데,
      백토 등이 혼합되어 높은 온도에서 구워낸 그릇을 사기(자기)라고 합니다.
    </p>
    <figure class="circle-hero" aria-hidden="true">
      <img id="circleImg" src="img/gong/do.png" alt="도자기 제작 장면">
    </figure>
  </div>
</section>

<section class="hscroll-new" id="crafts-hscroll">
  <div class="hscroll-sticky">
    <div class="hscroll-track" id="crafts-track">
      <article class="panel" id="hs-baekja">
        <div class="panel-header-collapsed">
           <span class="panel-number">01</span>
           <h3 class="panel-title">백자</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/b.png" alt="백자">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">01</span>
              <h3 class="panel-title">백자 · White Porcelain</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">CERAMICS / JOSEON DYNASTY</p>
              <p class="panel-desc">
                백자는 순수와 절제미를 상징하며, 조선시대 선비들의 정신을 담은 대표 도자기입니다. 순백의 유약과 단정한 비례감, 군더더기 없는 선이 특징으로, 일상용기부터 의례용, 달항아리 같은 대형 기물까지 폭넓게 제작되었습니다. 광주 분원 관요 등에서 정제된 백토와 높은 온도의 가마 소성이 더해져 맑고 단단한 질감을 얻었습니다.
              </p>
            </div>
          </div>
        </div>
      </article>
      <article class="panel" id="hs-cheongja">
        <div class="panel-header-collapsed">
           <span class="panel-number">02</span>
           <h3 class="panel-title">청자</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/ch.png" alt="청자">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">02</span>
              <h3 class="panel-title">청자 · Celadon</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">CERAMICS / GORYEO DYNASTY</p>
              <p class="panel-desc">
                청자는 비취빛(비색) 유약이 포인트로, 깊고 은은한 색조와 매끄러운 표면감이 돋보입니다. 연꽃·학·운문 등의 문양을 상감·음각 등 다양한 기법으로 표현했으며, 정교하면서도 절제된 장식미로 고려 귀족 문화의 미감을 보여줍니다. 가마의 위치와 소성 조건에 따라 색조가 미묘하게 달라지는 것도 매력입니다.
              </p>
            </div>
          </div>
        </div>
      </article>
      <article class="panel" id="hs-najeon">
         <div class="panel-header-collapsed">
           <span class="panel-number">03</span>
           <h3 class="panel-title">나전칠기</h3>
        </div>
        <div class="panel-content">
          <div class="panel-image-wrapper">
            <img class="panel-image" src="img/gong/n.png" alt="나전칠기">
          </div>
          <div class="panel-text-wrapper">
            <div class="panel-header">
              <span class="panel-number">03</span>
              <h3 class="panel-title">나전칠기</h3>
            </div>
            <div class="panel-footer">
              <p class="panel-meta">LACQUERWARE / TRADITIONAL</p>
              <p class="panel-desc">
                나전칠기는 얇게 간 자개 조각을 정교하게 배열하고, 여러 차례의 옻칠과 연마를 거쳐 깊은 광택을 완성하는 공예입니다. 전복·진주조개의 오묘한 색이 어두운 칠 바탕과 대비되어 화려하면서도 고급스러운 분위기를 만듭니다. 긴 건조·연마 공정을 통해 내구성과 표면 강도가 높아 실용성과 장식성이 함께 충족됩니다.
              </p>
            </div>
          </div>
        </div>
      </article>
    </div>
  </div>
</section>

<div class="un-section" id="un">
  <div class="image-list">
    <div class="image-item"><a href="explore.html?filter=baekja"><img src="img/gong/stack1.png" class="fade-in" alt="백자"></a></div>
    <div class="image-item"><a href="explore.html?filter=cheongja"><img src="img/gong/stack3.png" class="fade-in" alt="청자"></a></div>
    <div class="image-item"><a href="explore.html?filter=najeon"><img src="img/gong/stack2.png" class="fade-in" alt="나전칠기"></a></div>
  </div>
</div>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useRef } = React;

  /* ===== Utils ===== */
  function lerp(a,b,n){ return (1-n)*a + n*b; }
  function getLocalPointerPos(e, rect){
    let clientX = 0, clientY = 0;
    if (e.touches && e.touches.length > 0){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
    else { clientX = e.clientX; clientY = e.clientY; }
    return { x: clientX - rect.left, y: clientY - rect.top };
  }
  function getMouseDistance(p1, p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y; return Math.hypot(dx, dy); }

  /* ===== ImageTrail ===== */
  class ImageItem {
    DOM = { el:null, inner:null }; defaultStyle = { scale:1, x:0, y:0, opacity:0 }; rect=null;
    constructor(DOM_el){ this.DOM.el = DOM_el; this.DOM.inner = this.DOM.el.querySelector('.content__img-inner'); this.getRect(); this.initEvents(); }
    initEvents(){ this.resize = () => { if (typeof gsap !== 'undefined') gsap.set(this.DOM.el, this.defaultStyle); this.getRect(); }; window.addEventListener('resize', this.resize); } // Added gsap check
    getRect(){ this.rect = this.DOM.el.getBoundingClientRect(); }
  }
  class ImageTrailVariant1{
    constructor(container){
      this.container = container; this.DOM = { el: container };
      this.images = [...this.DOM.el.querySelectorAll('.content__img')].map(img => new ImageItem(img));
      this.imagesTotal = this.images.length; this.imgPosition = 0; this.zIndexVal = 1; this.isIdle = true;
      this.threshold = 90; this.minDelay  = 220; this._lastShownAt = 0;
      this.mousePos = { x:0, y:0 }; this.lastMousePos = { x:0, y:0 }; this.cacheMousePos = { x:0, y:0 };
      const handlePointerMove = ev => { const rect = this.container.getBoundingClientRect(); this.mousePos = getLocalPointerPos(ev, rect); };
      container.addEventListener('mousemove', handlePointerMove); container.addEventListener('touchmove', handlePointerMove);
      const initRender = ev => {
        const rect = this.container.getBoundingClientRect(); this.mousePos = getLocalPointerPos(ev, rect); this.cacheMousePos = { ...this.mousePos };
        requestAnimationFrame(() => this.render()); container.removeEventListener('mousemove', initRender); container.removeEventListener('touchmove', initRender);
      };
      container.addEventListener('mousemove', initRender); container.addEventListener('touchmove', initRender);
    }
    render(){
      const distance = getMouseDistance(this.mousePos, this.lastMousePos);
      this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1); this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);
      const now = performance.now();
      if (distance > this.threshold && (now - this._lastShownAt) > this.minDelay){
        this.showNextImage(); this.lastMousePos = { ...this.mousePos }; this._lastShownAt = now;
      }
      requestAnimationFrame(() => this.render());
    }
    showNextImage(){
      ++this.zIndexVal; this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
      const img = this.images[this.imgPosition];
      if (typeof gsap === 'undefined') return; // Added gsap check
      gsap.killTweensOf(img.DOM.el);
      gsap.timeline()
        .fromTo(img.DOM.el, { opacity: 1, scale: 1, zIndex: this.zIndexVal, x: this.cacheMousePos.x - img.rect.width/2, y: this.cacheMousePos.y - img.rect.height/2 },
          { duration: 0.6, ease: 'power1', x: this.mousePos.x - img.rect.width/2, y: this.mousePos.y - img.rect.height/2 }, 0)
        .to(img.DOM.el, { duration: 0.6, ease: 'power3', opacity: 0, scale: 0.2 }, 0.6);
    }
  }
  const variantMap = { 1: ImageTrailVariant1 };
  function ImageTrail({ items=[], variant=1 }){
    const containerRef = useRef(null);
    useEffect(() => {
      if(!containerRef.current) return;
      const Cls = variantMap[variant] || variantMap[1];
      new Cls(containerRef.current);
    }, [variant, items]);
    return (<div className="content" ref={containerRef}>{items.map((it, i) => { const src = typeof it === 'string' ? it : it.src;
          return (<div className="content__img" key={i}><img className="content__img-inner" src={src} alt="" decoding="async" onError={(e)=>{ e.currentTarget.parentElement.style.display='none'; }} /></div>);
        })}</div>);
  }

  /* ===== React Flowing Menu (explore와 동일 구조/가드) ===== */
  function FlowingMenu({ items = [] }) {
    useEffect(() => { items.forEach(item => { if (item.image) { const img = new Image(); img.src = item.image; } }); }, [items]);
    return (<div className="fm-menu-wrap"><nav className="fm-menu" aria-label="Hamburger items">{items.map((it, i) => <MenuItem key={i} {...it} />)}</nav></div>);
  }
  function MenuItem({ link = '#', text, image }) {
    const itemRef = useRef(null); const marqueeRef = useRef(null); const marqueeInnerRef = useRef(null);
    const animationDefaults = { duration: 0.6, ease: 'expo.out' };
    const dist = (x,y,x2,y2)=>{ const dx=x-x2, dy=y-y2; return dx*dx+dy*dy; };
    const closestEdge = (mx,my,w,h)=> dist(mx,my,w/2,0) < dist(mx,my,w/2,h) ? 'top':'bottom';
    const enter = (ev)=>{
      if (typeof gsap === 'undefined') return;
      if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return; const rect = itemRef.current.getBoundingClientRect();
      const x=(ev.clientX??0)-rect.left, y=(ev.clientY??0)-rect.top; const edge=closestEdge(x,y,rect.width,rect.height);
      gsap.timeline({ defaults: animationDefaults }).set(marqueeRef.current,{ y:edge==='top' ? '-101%':'101%' },0).set(marqueeInnerRef.current,{ y:edge==='top' ? '101%':'-101%' },0).to([marqueeRef.current,marqueeInnerRef.current],{ y:'0%' },0);
    };
    const leave = (ev)=>{
      if (typeof gsap === 'undefined') return;
      if (!itemRef.current || !marqueeRef.current || !marqueeInnerRef.current) return; const rect=itemRef.current.getBoundingClientRect();
      const x=(ev.clientX??0)-rect.left, y=(ev.clientY??0)-rect.top; const edge=closestEdge(x,y,rect.width,rect.height);
      gsap.timeline({ defaults: animationDefaults }).to(marqueeRef.current,{ y:edge==='top' ? '-101%':'101%' },0).to(marqueeInnerRef.current,{ y:edge==='top' ? '101%':'-101%' },0);
    };
    const onClick = () => { if (link && link.startsWith('#')) { if (window.toggleMenu) window.toggleMenu(false); } };
    const repeated = Array.from({ length:4 }).map((_,i)=>( <React.Fragment key={i}><span>{text}</span><div className="fm-marquee__img" style={{ backgroundImage:`url(${image})` }} /></React.Fragment> ));
    return (<div className="fm-menu__item" ref={itemRef}>
        <a className="fm-menu__item-link" href={link} onPointerEnter={enter} onPointerLeave={leave} onFocus={enter} onBlur={leave} onClick={onClick}>{text}</a>
        <div className="fm-marquee" ref={marqueeRef} aria-hidden="true"><div className="fm-marquee__inner-wrap" ref={marqueeInnerRef}><div className="fm-marquee__inner">{repeated}</div></div></div>
      </div>);
  }

  /* ===== Mount React bits ===== */
  (async () => {
    // ImageTrail mount
    const trailRoot = document.getElementById('image-trail-root');
    if (trailRoot) {
      const box = document.getElementById('trail-srcs'); const requested = box ? Array.from(box.querySelectorAll('img')).map(el => el.getAttribute('src')).filter(Boolean) : [];
      const testLoad = (url) => new Promise((res) => { const im = new Image(); im.onload  = () => res(url); im.onerror = () => res(null); im.src = url; });
      const results = await Promise.allSettled(requested.map(testLoad));
      const ok = results.map(r => (r.status==='fulfilled' ? r.value : null)).filter(Boolean);
      const fallback = ['img/gong/back/5.png','img/gong/back/a1.png','img/gong/b.png', /* Add more fallbacks if needed */ ];
      const usable = (ok.length ? ok : fallback).map(src => ({ src })); const variant = box?.dataset?.variant ? parseInt(box.dataset.variant, 10) : 1;
      if (ReactDOM.createRoot) {
         ReactDOM.createRoot(trailRoot).render(<ImageTrail items={usable} variant={variant} />);
      } else {
         ReactDOM.render(React.createElement(ImageTrail, { items: usable, variant: variant }), trailRoot);
      }
    }

    // FlowingMenu mount (explore 스타일, 중복 마운트 가드)
    const menuRoot = document.getElementById('react-menu-root');
    if (menuRoot && !menuRoot.__mounted) {
      menuRoot.__mounted = true;
      const menuItems = [
        { link: 'index.html',    text: '홈',   image: 'img/8.jpg' },
        { link: 'sumak.html',     text: '수막새', image: 'img/6.jpg' },
        { link: 'ceramics.html', text: '공예품', image: 'img/gong/do.png' },
        { link: 'hanbok.html',   text: '한복', image: 'img/han/bg.jpg' },
      ];
      if (ReactDOM.createRoot) {
        ReactDOM.createRoot(menuRoot).render(<FlowingMenu items={menuItems} />);
      } else {
        ReactDOM.render(React.createElement(FlowingMenu, { items: menuItems }), menuRoot);
      }
    }
  })();
</script>

<script>
  /* ===== Menu open/close ===== */
  (() => {
    const btn = document.getElementById('menuBtn');
    const overlay = document.getElementById('menuOverlay');
    const panel = document.getElementById('menuPanel');
    if(!btn || !overlay || !panel) return;
    function setOpen(open){
      btn.setAttribute('aria-expanded', String(open));
      overlay.classList.toggle('open', open);
      overlay.setAttribute('aria-hidden', String(!open));
      if (window.__lenis){ open ? window.__lenis.stop() : window.__lenis.start(); }
      else { document.body.style.overflow = open ? 'hidden' : ''; }
    }
    btn.addEventListener('click', () => setOpen(btn.getAttribute('aria-expanded') !== 'true'));
    overlay.addEventListener('click', () => setOpen(false));
    panel?.addEventListener('click', (e) => e.stopPropagation());
    window.addEventListener('keydown', (e) => { if(e.key === 'Escape') setOpen(false); });
    window.toggleMenu = function(next){ if (typeof next === 'boolean') setOpen(next); else setOpen(btn.getAttribute('aria-expanded') !== 'true'); };
  })();

  /* ===== Fit hero title ===== */
  document.addEventListener('DOMContentLoaded', () => {
    document.documentElement.classList.add('js');
    function fitHeroTitle(){
      const hero  = document.getElementById('hero');
      const title = document.getElementById('heroTitle');
      if(!hero || !title) return;
      title.style.transform = 'none'; // Reset transform before measuring
      const W_MARGIN = .96, H_MARGIN = .88;
      const cs   = getComputedStyle(hero);
      // Ensure clientWidth/Height are positive before calculations
      const heroClientWidth = Math.max(0, hero.clientWidth);
      const heroClientHeight = Math.max(0, hero.clientHeight);
      const wMax = (heroClientWidth  - (parseFloat(cs.paddingLeft)||0) - (parseFloat(cs.paddingRight)||0)) * W_MARGIN;
      const hMax = (heroClientHeight - (parseFloat(cs.paddingTop)||0)  - (parseFloat(cs.paddingBottom)||0)) * H_MARGIN;
      const rect = title.getBoundingClientRect();
      // Ensure rect dimensions are positive
      const rectWidth = Math.max(1, rect.width); // Avoid division by zero
      const rectHeight = Math.max(1, rect.height);
      const scale = Math.min(1, wMax/rectWidth, hMax/rectHeight);
      title.style.transformOrigin = 'center';
      title.style.transform = `scale(${scale})`;
    }
    // Use requestAnimationFrame for initial call after fonts ready
    (document.fonts?.ready || Promise.resolve()).then(() => { requestAnimationFrame(() => { fitHeroTitle(); }); });
    window.addEventListener('resize', fitHeroTitle);
  });

  /* ===== Lenis smooth scroll ===== */
  /* const lenis = new Lenis({ lerp: 0.09, smoothWheel: true, normalizeWheel: true });
  function raf(time){ lenis.raf(time); requestAnimationFrame(raf); }
  requestAnimationFrame(raf);
  window.__lenis = lenis;
*/
  /* ===== Interlude text progressive reveal ===== */
  (function () {
    const section = document.getElementById('overview');
    const p = document.getElementById('interlude-desc');
    if (!section || !p) return;
    const raw = p.textContent;
    const text = (raw || '').replace(/\s+/g, ' ').trim();
    if (!text) return;
    const words = text.split(' ');
    p.textContent = ''; // Clear original text
    const spans = words.map((w) => {
      const s = document.createElement('span');
      s.className = 'w';
      s.textContent = w;
      p.appendChild(s);
      return s;
    });
    function pinProgress() {
      const rect = section.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const denom = rect.height - vh;
      if (denom <= 0) return 1; // Return 1 if section is shorter than viewport
      return Math.max(0, Math.min(1, (0 - rect.top) / denom));
    }
    function render() {
      const prog = pinProgress();
      const N = spans.length;
      for (let i = 0; i < N; i++) {
        const t = (i + 1) / (N + 1); // Stagger threshold for each word
        const a = Math.max(0, Math.min(1, (prog - t) / 0.12)); // Animation progress for word i
        const op = 1 - Math.pow(1 - a, 3); // Eased opacity
        const ty = (1 - op) * 16; // Eased translation
        const el = spans[i];
        el.style.opacity = op.toFixed(3);
        el.style.transform = `translateY(${ty.toFixed(2)}px)`;
      }
      // Optimization: If fully revealed, set final styles and potentially detach listener
      if (prog >= 1) {
        spans.forEach((el) => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
        // Consider removing scroll listener here if performance is critical
      }
    }
    // Add passive:true for better scroll performance
    addEventListener('scroll', render, { passive: true });
    addEventListener('resize', render); // Re-render on resize
    requestAnimationFrame(render); // Initial render
  })();

  /* ===== Interlude circle parallax/scale ===== */
  (function(){
    const sec = document.getElementById('overview');
    const img = document.getElementById('circleImg');
    if(!sec || !img) return;
    function progress(){
      const rect = sec.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const denom = rect.height - vh;
      if (denom <= 0) return 1; // If shorter than viewport, progress is 1
      return Math.max(0, Math.min(1, (0 - rect.top) / denom)); // Clamp progress 0-1
    }
    function render(){
      const p = progress();
      const s = 1 + 0.12*p; // Scale from 1 to 1.12
      const ty = - (window.innerHeight * 0.06) * p; // Translate up slightly
      img.style.transform = `translateY(${ty}px) scale(${s})`;
    }
    addEventListener('scroll', render, { passive:true }); // Use passive listener
    addEventListener('resize', render); // Update on resize
    requestAnimationFrame(render); // Initial render
  })();




/* ===== Horizontal panels: improved stable one-by-one opening ===== */
(() => {
  const sec   = document.getElementById('crafts-hscroll');
  const track = document.getElementById('crafts-track');
  if (!sec || !track) return;

  const panels = Array.from(track.querySelectorAll('.panel'));
  const count  = panels.length;
  if (count === 0) return; // Exit if no panels

  document.documentElement.style.setProperty('--panels', String(count));

  const steps = Math.max(1, count - 1); // index range 0..steps
  const vh    = () => window.innerHeight || document.documentElement.clientHeight;

  /* ---- Calculate progress (0-1) ---- */
  function progress(){
    const r = sec.getBoundingClientRect();
    const denom = r.height - vh();
    if (denom <= 0) return 0; // Avoid division by zero or negative values
    return Math.max(0, Math.min(1, (0 - r.top) / denom)); // Clamp 0-1
  }

  /* ---- Calculate target index from progress ---- */
  function idxFromProgress(p){
    const clamped = Math.max(0, Math.min(1, p));
    return Math.round(clamped * steps); // Round to nearest index
  }

  /* ---- Check if section is pinned in viewport ---- */
  let pinnedSince = null;
  function inPinnedView(){
    const r = sec.getBoundingClientRect();
    const pinned = r.top <= 0 && r.bottom >= vh();
    if (pinned && pinnedSince === null) pinnedSince = Date.now(); // Record when pinning started
    if (!pinned) pinnedSince = null; // Reset when not pinned
    return pinned;
  }

  /* ---- State variables ---- */
  let activeIdx   = 0;
  let openTimer   = null;
  let idleTimer   = null;
  let isSnapping  = false;  // Lock during snap animation
  let lastSnapAt  = 0;      // Timestamp of last snap start
  let lastRaw     = 0;      // Last raw progress (0..steps)
  let userInteracted = false; // Track if user has scrolled/touched etc.
  let lastScrollTime = 0;   // Timestamp of last scroll event

  const FLEX_DUR_MS       = 1100; // Panel opening duration (matches CSS)
  const IDLE_DELAY_MS     = 650;  // Delay before snapping after scroll stops
  const IDLE_COOLDOWN_MS  = 600;  // Cooldown after a snap to prevent immediate re-snap
  const RAW_HYSTERESIS    = 0.55; // Threshold to move to next/prev panel

  /* ---- Set active panel (expand and show content) ---- */
  function setActive(idx, opts = { preserveIfSame:true }) {
    const target = Math.max(0, Math.min(steps, idx)); // Clamp index
    if (opts.preserveIfSame && target === activeIdx) return; // No change needed

    activeIdx = target;

    // Reset other panels
    panels.forEach((el, i) => {
      if (i !== activeIdx) el.classList.remove('is-active', 'is-open', 'show-footer');
    });

    // Activate the target panel
    const activePanel = panels[activeIdx];
    if (activePanel) activePanel.classList.add('is-active');

    // Show content after flex animation completes
    clearTimeout(openTimer);
    openTimer = setTimeout(() => {
      const currentPanel = panels[activeIdx];
      if (!currentPanel) return;
      currentPanel.classList.add('is-open');
      currentPanel.classList.add('show-footer'); // Add class to show footer
    }, FLEX_DUR_MS);
  }

  /* ---- Smooth scroll to a specific index (vertical snap) ---- */
  const easing = t => 1 - Math.pow(1 - t, 4); // Ease-out quart
  function snapToIndex(idx){
    const i = Math.max(0, Math.min(steps, idx)); // Clamp index
    const r = sec.getBoundingClientRect();
    const sectionTop = window.scrollY + r.top;
    const denom = r.height - vh();
    if (denom <= 0) return; // Cannot snap if section height <= viewport height

    const targetY = sectionTop + denom * (i / steps); // Calculate target scroll position

    isSnapping = true;
    lastSnapAt = Date.now();

    if (window.__lenis && typeof window.__lenis.scrollTo === 'function'){
      // Use Lenis if available
      window.__lenis.scrollTo(targetY, { duration: 1.05, easing });
    } else {
      // Use native smooth scroll otherwise
      window.scrollTo({ top: targetY, behavior: 'smooth' });
    }

    // Unlock after a delay (slightly shorter than animation duration)
    setTimeout(() => { isSnapping = false; }, 900);
  }

  /* ---- Snap logic based on scroll progress when idle ---- */
  function idleSnap(){
    // Only snap if pinned, not already snapping, and enough time has passed since last snap
    if (!inPinnedView() || isSnapping || (Date.now() - lastSnapAt < IDLE_COOLDOWN_MS)) return;

    const p   = progress();
    const raw = p * steps; // Raw progress (0..steps)
    const diffFromActive = Math.abs(raw - activeIdx); // How far from current active center

    // Prevent auto-snap immediately on entering view unless user interacts or waits
    if (!userInteracted) {
      if (!pinnedSince || (Date.now() - pinnedSince) < 600) {
        lastRaw = raw; // Update state but don't snap yet
        return;
      }
    }

    // Ignore tiny scroll changes (jitter reduction)
    if (Math.abs(raw - lastRaw) < 0.12) {
      lastRaw = raw;
      return;
    }

    // If scrolled far enough from the center, snap to the new target
    if (diffFromActive >= RAW_HYSTERESIS) {
      const target = idxFromProgress(p);
      if (target !== activeIdx) {
        setActive(target, { preserveIfSame:false });
        snapToIndex(target);
      }
    } else {
      // If not far enough, snap back to the current active index (optional, can be removed)
      // snapToIndex(activeIdx);
    }

    lastRaw = raw; // Update last raw position
  }

  // Debounced call to idleSnap after scrolling stops
  function scheduleIdleSnap(){
    clearTimeout(idleTimer);
    idleTimer = setTimeout(idleSnap, IDLE_DELAY_MS);
  }

  /* ---- Initialization ---- */
  setActive(0, { preserveIfSame:false }); // Activate first panel initially
  lastRaw = progress() * steps; // Set initial raw progress
  if (inPinnedView()) pinnedSince = Date.now(); // Check if already pinned on load

  /* ---- Event Listeners ---- */

  // Wheel event for step-by-step navigation
  let wheelAccum = 0;
  let lastWheelAt = 0;
  let lastWheelSign = 0;
  const WHEEL_STEP_THRESHOLD = 120; // Accumulation needed for one step
  const WHEEL_COOLDOWN       = 550; // Cooldown between wheel steps

  window.addEventListener('wheel', (e)=>{
    if (!inPinnedView()) return; // Only act when pinned

    userInteracted = true; // Mark interaction
    lastScrollTime = Date.now(); // Track last scroll activity

    if (isSnapping) { e.preventDefault(); return; } // Prevent interference during snap

    const now = Date.now();
    const dy  = e.deltaY || 0;
    const sign = Math.sign(dy);

    // Reset accumulator if direction changes
    if (sign !== 0 && sign !== lastWheelSign) wheelAccum = 0;
    lastWheelSign = sign;
    wheelAccum += dy;

    // Check if threshold and cooldown are met
    const ready = Math.abs(wheelAccum) >= WHEEL_STEP_THRESHOLD && (now - lastWheelAt) >= WHEEL_COOLDOWN;
    if (ready){
      e.preventDefault(); // Prevent default page scroll
      const next = activeIdx + (wheelAccum > 0 ? 1 : -1); // Calculate next index
      wheelAccum = 0; // Reset accumulator
      lastWheelAt = now; // Update timestamp

      setActive(next, { preserveIfSame:false }); // Set new active panel
      snapToIndex(next); // Snap to it
    } else {
      scheduleIdleSnap(); // If not ready, just schedule idle check
    }
  }, { passive:false }); // Use active listener to allow preventDefault

  // Touch swipe events
  let touchStartY = null;
  sec.addEventListener('touchstart', e => { touchStartY = e.touches[0].clientY; userInteracted = true; }, { passive:true });
  sec.addEventListener('touchend', e => {
    if (!inPinnedView() || touchStartY == null) return;
    const dy = (e.changedTouches[0].clientY - touchStartY);
    touchStartY = null; // Reset start position

    if (Math.abs(dy) > 70) { // Swipe threshold
      const next = activeIdx + (dy < 0 ? 1 : -1); // Determine direction
      setActive(next, { preserveIfSame:false });
      snapToIndex(next);
    } else {
      scheduleIdleSnap(); // If not a significant swipe, schedule idle check
    }
  }, { passive:true });

  // Mark interaction on pointer/key events
  window.addEventListener('pointerdown', () => { userInteracted = true; }, { passive:true });
  window.addEventListener('keydown', () => { userInteracted = true; }, { passive:true });

  // Schedule idle snap check on scroll and resize events
  window.addEventListener('scroll', () => { lastScrollTime = Date.now(); if (inPinnedView()) scheduleIdleSnap(); }, { passive:true });
  window.addEventListener('resize', () => { if (inPinnedView()) scheduleIdleSnap(); });

})();

  // Back button event listener removed

</script>

</body>
</html>